<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KQ Video Player</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .video-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
        }

        #player {
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
            margin-top: 10px;
        }

        .controls button {
            background: #0f3460;
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .controls button:hover {
            background: #e94560;
        }

        .controls button:disabled {
            background: #333;
            cursor: not-allowed;
        }

        .time-display {
            font-family: monospace;
            font-size: 14px;
            color: #aaa;
        }

        .current-chapter {
            padding: 10px 15px;
            background: #16213e;
            border-radius: 8px;
            margin-top: 10px;
        }

        .current-chapter h3 {
            color: #e94560;
            margin-bottom: 5px;
        }

        .chapter-sidebar {
            width: 350px;
            background: #16213e;
            overflow-y: auto;
            border-left: 1px solid #0f3460;
        }

        .sidebar-header {
            padding: 20px;
            background: #0f3460;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sidebar-header h2 {
            margin-bottom: 10px;
        }

        .sidebar-header input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            background: #1a1a2e;
            color: #fff;
            font-size: 14px;
        }

        .position-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }

        .position-selector label {
            font-size: 13px;
            color: #aaa;
        }

        .position-selector select {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            background: #1a1a2e;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
        }

        #highlightCount {
            font-size: 12px;
            color: #e94560;
            font-weight: 600;
        }

        .win-prob-plot {
            width: 100%;
            height: 40px;
            margin-top: 6px;
            background: #1a1a2e;
            border-radius: 4px;
            cursor: pointer;
        }

        .win-prob-plot:hover {
            background: #252545;
        }

        .win-prob-plot svg {
            width: 100%;
            height: 100%;
        }

        .chapter-list {
            padding: 10px;
        }

        .chapter-item {
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 4px;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .chapter-item:hover {
            background: #0f3460;
        }

        .chapter-item.active {
            background: #0f3460;
            border-left-color: #e94560;
        }

        .chapter-item.gold-win {
            border-right: 3px solid #ffd700;
        }

        .chapter-item.blue-win {
            border-right: 3px solid #4a90d9;
        }

        /* Set styling */
        .chapter-item.set-start {
            margin-top: 16px;
            padding: 14px;
            background: #0f3460;
            border-left: 3px solid #e94560;
        }

        .chapter-item.set-start:first-child {
            margin-top: 0;
        }

        .chapter-item.in-set {
            margin-left: 20px;
            padding: 8px 12px;
            font-size: 0.9em;
            opacity: 0.85;
        }

        .chapter-item.in-set .chapter-title {
            font-size: 0.95em;
        }

        .chapter-item.in-set .chapter-time,
        .chapter-item.in-set .chapter-meta {
            font-size: 11px;
        }

        .set-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #e94560;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .chapter-time {
            font-family: monospace;
            font-size: 12px;
            color: #888;
            margin-bottom: 4px;
        }

        .chapter-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .chapter-meta {
            font-size: 12px;
            color: #aaa;
        }

        .chapter-meta .winner {
            font-weight: 600;
        }

        .chapter-meta .gold { color: #ffd700; }
        .chapter-meta .blue { color: #4a90d9; }

        .kd-stats {
            color: #e94560;
            font-weight: 600;
        }

        .good-prob {
            color: #4caf50;
            font-weight: 600;
        }

        .bad-prob {
            color: #f44336;
            font-weight: 600;
        }

        .load-section {
            padding: 20px;
            text-align: center;
        }

        .keyboard-hints {
            font-size: 15px;
            font-weight: 600;
            color: #aaa;
            margin-top: 10px;
            line-height: 1.8;
        }

        .keyboard-hints kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
        }

        /* Mobile styles - use pointer:coarse to detect touch devices */
        @media (pointer: coarse), (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .chapter-sidebar {
                display: none;
            }

            .video-section {
                height: 100vh;
                padding: 10px;
            }

            .keyboard-hints {
                display: none;
            }

            .controls {
                display: none;
            }

            .current-chapter {
                display: none;
            }

            .mobile-toggle {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 44px;
                height: 44px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(255, 255, 255, 0.3);
                color: white;
                font-size: 22px;
                z-index: 100;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }

            .mobile-controls {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(4px);
                -webkit-backdrop-filter: blur(4px);
                padding: 12px;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                z-index: 99;
            }

            .mobile-controls.visible {
                transform: translateY(0);
            }

            .mobile-nav-row {
                display: flex;
                gap: 8px;
                margin-bottom: 10px;
            }

            /* Landscape: spread buttons to edges */
            @media (orientation: landscape) {
                .mobile-nav-row {
                    justify-content: space-between;
                    gap: 4px;
                }

                .mobile-nav-row button {
                    flex: 0 1 auto;
                    padding: 10px 12px;
                }

                .mobile-position-row {
                    max-width: 50%;
                    margin: 0 auto;
                }
            }

            .mobile-nav-row button {
                flex: 1;
                padding: 10px 6px;
                font-size: 13px;
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                border-radius: 6px;
                cursor: pointer;
            }

            .mobile-nav-row button:active {
                background: rgba(255, 255, 255, 0.3);
            }

            .mobile-position-row {
                display: flex;
                gap: 10px;
                align-items: center;
            }

            .mobile-position-row select {
                flex: 1;
                padding: 10px;
                font-size: 16px;
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                border-radius: 6px;
            }

            .mobile-position-row span {
                color: #e94560;
                font-weight: 600;
                font-size: 14px;
            }
        }

        /* Hide mobile elements on desktop (non-touch devices above 768px) */
        @media (pointer: fine) and (min-width: 769px) {
            .mobile-toggle, .mobile-controls {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-section">
            <div class="video-wrapper">
                <div id="player"></div>
            </div>

            <div class="controls">
                <button id="prevChapter" title="Previous chapter">⏮ Prev</button>
                <button id="nextChapter" title="Next chapter">Next ⏭</button>
                <button id="playPause">▶ Play</button>
                <span class="time-display" id="timeDisplay">0:00 / 0:00</span>
            </div>

            <div class="current-chapter" id="currentChapterInfo">
            </div>

            <div class="keyboard-hints">
                <kbd>←</kbd><kbd>→</kbd> Seek 5s &nbsp;
                <kbd>J</kbd><kbd>L</kbd> Seek 10s &nbsp;
                <kbd>Space</kbd> Play/Pause<br>
                <kbd>G</kbd> Game (Shift: prev) &nbsp;
                <kbd>S</kbd> Set (Shift: prev) &nbsp;
                <kbd>E</kbd> Egg/queen kill (Shift: prev)<br>
                <kbd>1</kbd>-<kbd>0</kbd> Select position &nbsp;
                <kbd>H</kbd> Player highlight (Shift: prev)
            </div>
        </div>

        <div class="chapter-sidebar">
            <div class="sidebar-header">
                <h2>Chapters</h2>
                <input type="text" id="chapterFilter" placeholder="Filter by map, winner...">
                <div class="position-selector">
                    <label for="positionSelect">Position:</label>
                    <select id="positionSelect">
                        <option value="">Select player...</option>
                        <option value="10">1 - Blue Checkers</option>
                        <option value="8">2 - Blue Skull</option>
                        <option value="2">3 - Blue Queen</option>
                        <option value="9">4 - Blue Abs</option>
                        <option value="7">5 - Blue Stripes</option>
                        <option value="6">6 - Gold Checkers</option>
                        <option value="4">7 - Gold Skull</option>
                        <option value="1">8 - Gold Queen</option>
                        <option value="5">9 - Gold Abs</option>
                        <option value="3">0 - Gold Stripes</option>
                    </select>
                    <span id="highlightCount"></span>
                </div>
            </div>
            <div class="chapter-list" id="chapterList">
            </div>
        </div>
    </div>

    <!-- Mobile toggle button -->
    <button class="mobile-toggle" id="mobileToggle">✕</button>

    <!-- Mobile control bar -->
    <div class="mobile-controls visible" id="mobileControls">
        <div class="mobile-nav-row">
            <button id="mPrevSet">◀◀ S</button>
            <button id="mPrevGame">◀ G</button>
            <button id="mPrevHighlight">◀ H</button>
            <button id="mNextHighlight">H ▶</button>
            <button id="mNextGame">G ▶</button>
            <button id="mNextSet">S ▶▶</button>
        </div>
        <div class="mobile-position-row">
            <select id="mobilePositionSelect">
                <option value="">Select player...</option>
                <option value="10">1 - Blue Checkers</option>
                <option value="8">2 - Blue Skull</option>
                <option value="2">3 - Blue Queen</option>
                <option value="9">4 - Blue Abs</option>
                <option value="7">5 - Blue Stripes</option>
                <option value="6">6 - Gold Checkers</option>
                <option value="4">7 - Gold Skull</option>
                <option value="1">8 - Gold Queen</option>
                <option value="5">9 - Gold Abs</option>
                <option value="3">0 - Gold Stripes</option>
            </select>
            <span id="mobileHighlightCount"></span>
        </div>
    </div>

    <input type="file" id="chaptersInput" accept=".json" style="display: none;">

    <!-- YouTube IFrame API -->
    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        const chapterList = document.getElementById('chapterList');
        const currentChapterInfo = document.getElementById('currentChapterInfo');
        const timeDisplay = document.getElementById('timeDisplay');
        const chapterFilter = document.getElementById('chapterFilter');
        const playPauseBtn = document.getElementById('playPause');

        let player;
        let chapters = [];
        let queenKills = [];  // Flat list of all queen kill timestamps
        let currentChapterIndex = -1;
        let lastQueenKillIndex = -1;  // Track last navigated queen kill
        let timeUpdateInterval;

        // Player highlight state
        let selectedPosition = null;
        let playerHighlights = [];  // Filtered events for selected position
        let lastHighlightIndex = -1;

        // Seconds to seek before a highlight event
        const HIGHLIGHT_SEEK_BUFFER = 2.5;

        // YouTube video ID
        const VIDEO_ID = 'UmxLa4CW9cY';

        // Initialize YouTube player
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                videoId: VIDEO_ID,
                playerVars: {
                    'autoplay': 0,
                    'controls': 1,
                    'rel': 0,
                    'modestbranding': 1,
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        function onPlayerReady(event) {
            console.log('YouTube player ready');
            // Start time update interval
            timeUpdateInterval = setInterval(updateCurrentChapter, 500);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseBtn.textContent = '⏸ Pause';
            } else {
                playPauseBtn.textContent = '▶ Play';
            }
        }

        // Get current time from YouTube player
        function getCurrentTime() {
            return player && player.getCurrentTime ? player.getCurrentTime() : 0;
        }

        // Get video duration
        function getDuration() {
            return player && player.getDuration ? player.getDuration() : 0;
        }

        // Seek to time
        function seekTo(seconds) {
            if (player && player.seekTo) {
                player.seekTo(seconds, true);
            }
        }

        // Play/Pause
        function togglePlayPause() {
            if (!player) return;
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        // Format time as M:SS or H:MM:SS
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) {
                return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Find chapter at current time
        function findChapterAtTime(time) {
            for (let i = chapters.length - 1; i >= 0; i--) {
                if (time >= chapters[i].start_time) {
                    return i;
                }
            }
            return -1;
        }

        // Update current chapter display
        function updateCurrentChapter() {
            const currentTime = getCurrentTime();
            const newIndex = findChapterAtTime(currentTime);

            if (newIndex !== currentChapterIndex) {
                currentChapterIndex = newIndex;

                // Update sidebar highlighting
                document.querySelectorAll('.chapter-item').forEach((el, i) => {
                    el.classList.toggle('active', i === currentChapterIndex);
                });

                // Scroll active chapter into view
                const activeEl = document.querySelector('.chapter-item.active');
                if (activeEl) {
                    activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            // Update info panel
            if (currentChapterIndex >= 0) {
                const ch = chapters[currentChapterIndex];
                currentChapterInfo.innerHTML = `
                    <h3>${ch.title}</h3>
                    <p>
                        <span class="${ch.winner}">${ch.winner}</span> wins by ${ch.win_condition}
                        &nbsp;|&nbsp; Duration: ${formatTime(ch.duration)}
                        &nbsp;|&nbsp; <a href="${ch.hivemind_url}" target="_blank" style="color: #e94560;">HiveMind</a>
                    </p>
                `;
            }

            // Update time display
            timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(getDuration())}`;
        }

        // Calculate net win probability change for a player in a chapter
        function calculateNetWinProb(ch, positionId) {
            if (!positionId || !ch.player_events) return null;
            const pos = parseInt(positionId);
            let netDelta = 0;

            for (const evt of ch.player_events) {
                if (evt.positions && evt.positions.includes(pos)) {
                    netDelta += evt.delta;
                }
            }

            return netDelta;
        }

        // Find high-impact time ranges for a player in a chapter
        function findHighImpactRanges(ch, positionId) {
            if (!positionId || !ch.player_events) return [];
            const pos = parseInt(positionId);

            // Get all events for this player sorted by time
            const playerEvents = ch.player_events
                .filter(evt => evt.positions && evt.positions.includes(pos) && Math.abs(evt.delta) >= 0.05)
                .sort((a, b) => a.time - b.time);

            if (playerEvents.length === 0) return [];

            // Cluster nearby events (within 5 seconds)
            const ranges = [];
            let rangeStart = null;
            let rangeEnd = null;
            let rangeDelta = 0;

            for (const evt of playerEvents) {
                if (rangeStart === null) {
                    rangeStart = evt.time;
                    rangeEnd = evt.time;
                    rangeDelta = evt.delta;
                } else if (evt.time - rangeEnd <= 5) {
                    rangeEnd = evt.time;
                    rangeDelta += evt.delta;
                } else {
                    if (Math.abs(rangeDelta) >= 0.10) {
                        ranges.push({ start: rangeStart, end: rangeEnd, delta: rangeDelta });
                    }
                    rangeStart = evt.time;
                    rangeEnd = evt.time;
                    rangeDelta = evt.delta;
                }
            }
            // Don't forget the last range
            if (rangeStart !== null && Math.abs(rangeDelta) >= 0.10) {
                ranges.push({ start: rangeStart, end: rangeEnd, delta: rangeDelta });
            }

            return ranges;
        }

        // Calculate K/D stats for a chapter and selected position
        function calculateKD(ch, positionId) {
            if (!positionId || !ch.kill_events) return null;
            const pos = parseInt(positionId);
            let kills = 0;
            let deaths = 0;

            for (const evt of ch.kill_events) {
                if (evt.killer === pos) kills++;
                if (evt.victim === pos) deaths++;
            }

            return { kills, deaths };
        }

        // Check if a position is on the gold team
        function isGoldTeam(positionId) {
            const pos = parseInt(positionId);
            // Gold: position 1 (queen), 3, 4, 5, 6 (workers)
            // Blue: position 2 (queen), 7, 8, 9, 10 (workers)
            return pos === 1 || (pos >= 3 && pos <= 6);
        }

        // Render win probability plot for a chapter
        function renderWinProbPlot(ch, index) {
            if (!ch.win_timeline || ch.win_timeline.length < 2) return '';

            const width = 280;
            const height = 36;
            const padding = 2;

            const timeline = ch.win_timeline;
            const startTime = ch.start_time;
            const endTime = ch.end_time;
            const duration = endTime - startTime;

            // Determine if we need to flip perspective for gold team
            const flipForGold = selectedPosition && isGoldTeam(selectedPosition);

            // Find high-impact ranges for selected player
            const highImpactRanges = selectedPosition ? findHighImpactRanges(ch, selectedPosition) : [];

            // Create highlight rectangles for high-impact ranges
            // Green = good for player's team, Red = bad for player's team
            const highlightsHtml = highImpactRanges.map(range => {
                const x1 = padding + ((range.start - startTime) / duration) * (width - 2 * padding);
                const x2 = padding + ((range.end - startTime) / duration) * (width - 2 * padding);
                const rangeWidth = Math.max(x2 - x1, 6); // Minimum width of 6px
                // For blue player: positive delta = good (green)
                // For gold player: negative delta = good (green) because delta is from blue's perspective
                const isGoodForPlayer = flipForGold ? range.delta < 0 : range.delta > 0;
                const color = isGoodForPlayer ? 'rgba(76, 175, 80, 0.4)' : 'rgba(244, 67, 54, 0.4)';
                return `<rect x="${x1 - 2}" y="0" width="${rangeWidth + 4}" height="${height}" fill="${color}"/>`;
            }).join('');

            // Build SVG path for win probability line
            let pathD = '';

            for (let i = 0; i < timeline.length; i++) {
                const pt = timeline[i];
                const x = padding + ((pt.t - startTime) / duration) * (width - 2 * padding);
                // Flip probability for gold team perspective
                const prob = flipForGold ? (1 - pt.p) : pt.p;
                const y = height - padding - (prob * (height - 2 * padding));

                if (i === 0) {
                    pathD += `M ${x} ${y}`;
                } else {
                    pathD += ` L ${x} ${y}`;
                }
            }

            return `
                <div class="win-prob-plot" data-chapter="${index}">
                    <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                        ${highlightsHtml}
                        <line x1="${padding}" y1="${height/2}" x2="${width-padding}" y2="${height/2}"
                              stroke="#333" stroke-width="1" stroke-dasharray="2,2"/>
                        <path d="${pathD}" fill="none" stroke="#888" stroke-width="1.5"/>
                    </svg>
                </div>
            `;
        }

        // Render chapter list
        function renderChapters(filter = '') {
            const filterLower = filter.toLowerCase();

            chapterList.innerHTML = chapters
                .map((ch, i) => {
                    // Filter
                    if (filter) {
                        const searchText = `${ch.map} ${ch.winner} ${ch.win_condition} ${ch.game_id}`.toLowerCase();
                        if (!searchText.includes(filterLower)) {
                            return '';
                        }
                    }

                    const winnerClass = ch.winner === 'gold' ? 'gold-win' : 'blue-win';
                    const activeClass = i === currentChapterIndex ? 'active' : '';
                    const setClass = ch.is_set_start ? 'set-start' : 'in-set';
                    const setLabel = ch.is_set_start ? `<div class="set-label">Set ${ch.set_number}</div>` : '';

                    const plotHtml = renderWinProbPlot(ch, i);

                    // Calculate K/D and net win prob for selected position
                    let statsHtml = '';
                    if (selectedPosition) {
                        const kd = calculateKD(ch, selectedPosition);
                        const netProb = calculateNetWinProb(ch, selectedPosition);
                        if (kd) {
                            // Flip net prob for gold team (delta is from blue's perspective)
                            const playerNetProb = isGoldTeam(selectedPosition) ? -netProb : netProb;
                            const netProbStr = playerNetProb !== null ?
                                `<span class="${playerNetProb >= 0 ? 'good-prob' : 'bad-prob'}">${playerNetProb >= 0 ? '+' : ''}${(playerNetProb * 100).toFixed(0)}%</span>` : '';
                            statsHtml = `<span class="kd-stats">${kd.kills}/${kd.deaths}</span> ${netProbStr}`;
                        }
                    }

                    return `
                        <div class="chapter-item ${winnerClass} ${activeClass} ${setClass}" data-index="${i}">
                            ${setLabel}
                            <div class="chapter-time">${formatTime(ch.start_time)} - ${formatTime(ch.end_time)}</div>
                            <div class="chapter-title">${ch.title}</div>
                            <div class="chapter-meta">
                                <span class="winner ${ch.winner}">${ch.winner}</span> ${ch.win_condition}
                                &nbsp;|&nbsp; ${formatTime(ch.duration)}
                                ${statsHtml ? '&nbsp;|&nbsp;' + statsHtml : ''}
                            </div>
                            ${plotHtml}
                        </div>
                    `;
                })
                .join('');

            // Add click handlers for chapter items (not on plot)
            document.querySelectorAll('.chapter-item').forEach(el => {
                el.addEventListener('click', (e) => {
                    // Don't trigger if clicking on plot
                    if (e.target.closest('.win-prob-plot')) return;
                    const index = parseInt(el.dataset.index);
                    jumpToChapter(index);
                });
            });

            // Add click handlers for plots (seek to specific time)
            document.querySelectorAll('.win-prob-plot').forEach(plot => {
                plot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const chapterIndex = parseInt(plot.dataset.chapter);
                    const ch = chapters[chapterIndex];
                    const rect = plot.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / rect.width;
                    const targetTime = ch.start_time + clickX * (ch.end_time - ch.start_time);
                    seekTo(targetTime);
                    if (player) player.playVideo();
                });
            });
        }

        // Jump to chapter
        function jumpToChapter(index) {
            if (index >= 0 && index < chapters.length) {
                const targetTime = chapters[index].start_time;
                console.log(`Jumping to chapter ${index}: ${chapters[index].title} at ${targetTime}s`);
                seekTo(targetTime);
                currentChapterIndex = index;
                updateCurrentChapter();
                if (player) player.playVideo();
            }
        }

        // Navigation
        function prevChapter() {
            const idx = findChapterAtTime(getCurrentTime());
            if (idx > 0) {
                jumpToChapter(idx - 1);
            } else if (idx === 0) {
                jumpToChapter(0);
            }
        }

        function nextChapter() {
            const idx = findChapterAtTime(getCurrentTime());
            if (idx < chapters.length - 1) {
                jumpToChapter(idx + 1);
            } else if (idx === -1 && chapters.length > 0) {
                jumpToChapter(0);
            }
        }

        // Set navigation
        function nextSet() {
            const idx = findChapterAtTime(getCurrentTime());
            for (let i = idx + 1; i < chapters.length; i++) {
                if (chapters[i].is_set_start) {
                    jumpToChapter(i);
                    return;
                }
            }
        }

        function prevSet() {
            const idx = findChapterAtTime(getCurrentTime());
            // If we're past the start of current set's first game, go to current set start
            const currentSetStart = chapters.findIndex((ch, i) =>
                i <= idx && ch.is_set_start &&
                (i === idx || !chapters.slice(i + 1, idx + 1).some(c => c.is_set_start))
            );

            // Find previous set start
            for (let i = idx - 1; i >= 0; i--) {
                if (chapters[i].is_set_start) {
                    // If we're at the start of current set, go to previous set
                    if (i === currentSetStart && getCurrentTime() - chapters[i].start_time < 2) {
                        continue;
                    }
                    jumpToChapter(i);
                    return;
                }
            }
            // If no previous set, go to first chapter
            if (chapters.length > 0) {
                jumpToChapter(0);
            }
        }

        // Queen kill (egg) navigation
        function findQueenKillIndexAtTime(time) {
            // Find the queen kill at or just before the given time
            for (let i = queenKills.length - 1; i >= 0; i--) {
                if (queenKills[i].time <= time + 2) {
                    return i;
                }
            }
            return -1;
        }

        function nextQueenKill() {
            if (queenKills.length === 0) return;

            const currentTime = getCurrentTime();
            let nextIndex;

            // If we're near the last jumped-to kill, go to the next one
            if (lastQueenKillIndex >= 0 && lastQueenKillIndex < queenKills.length - 1) {
                const lastKillTime = queenKills[lastQueenKillIndex].time;
                if (Math.abs(currentTime - (lastKillTime - 1)) < 3) {
                    nextIndex = lastQueenKillIndex + 1;
                }
            }

            // Otherwise find based on current time
            if (nextIndex === undefined) {
                nextIndex = findQueenKillIndexAtTime(currentTime) + 1;
            }

            if (nextIndex < queenKills.length) {
                lastQueenKillIndex = nextIndex;
                seekTo(queenKills[nextIndex].time - 1);
                if (player) player.playVideo();
            }
        }

        function prevQueenKill() {
            if (queenKills.length === 0) return;

            const currentTime = getCurrentTime();

            // If we have a last jumped-to kill, check if we should replay it or go back
            if (lastQueenKillIndex >= 0) {
                const lastKillTime = queenKills[lastQueenKillIndex].time;
                const targetTime = lastKillTime - 1;

                // If we're past the kill moment, replay this kill
                if (currentTime > lastKillTime - 0.5) {
                    seekTo(targetTime);
                    if (player) player.playVideo();
                    return;
                }

                // If we're near the start (within 2s), go to previous kill
                if (Math.abs(currentTime - targetTime) < 2 && lastQueenKillIndex > 0) {
                    lastQueenKillIndex = lastQueenKillIndex - 1;
                    seekTo(queenKills[lastQueenKillIndex].time - 1);
                    if (player) player.playVideo();
                    return;
                }
            }

            // Otherwise find based on current time
            const idx = findQueenKillIndexAtTime(currentTime);
            if (idx >= 0) {
                lastQueenKillIndex = idx;
                seekTo(queenKills[idx].time - 1);
                if (player) player.playVideo();
            }
        }

        // Player highlight functions
        function updatePlayerHighlights() {
            const pos = parseInt(selectedPosition);
            playerHighlights = [];
            lastHighlightIndex = -1;

            if (!pos) {
                document.getElementById('highlightCount').textContent = '';
                return;
            }

            // Queen positions have higher thresholds (bigger swings are normal)
            const isQueen = (pos === 1 || pos === 2);
            const baseThreshold = isQueen ? 0.20 : 0.15;

            // Collect all events for this position
            let allEvents = [];
            for (const ch of chapters) {
                if (ch.player_events) {
                    for (const evt of ch.player_events) {
                        if (evt.positions && evt.positions.includes(pos)) {
                            allEvents.push({
                                time: evt.time,
                                delta: evt.delta,
                                type: evt.type,
                                game_id: ch.game_id,
                                set_number: ch.set_number
                            });
                        }
                    }
                }
            }

            // Sort by time
            allEvents.sort((a, b) => a.time - b.time);

            // Calculate impact score with clustering bonus
            // Events within 5 seconds of other impactful events get boosted
            const windowSize = 5; // seconds
            for (let i = 0; i < allEvents.length; i++) {
                let clusterScore = Math.abs(allEvents[i].delta);

                // Look for nearby events and sum their impact
                for (let j = 0; j < allEvents.length; j++) {
                    if (i !== j && Math.abs(allEvents[i].time - allEvents[j].time) < windowSize) {
                        clusterScore += Math.abs(allEvents[j].delta) * 0.3; // 30% bonus for nearby events
                    }
                }
                allEvents[i].score = clusterScore;
            }

            // Filter by threshold and take top events per set
            const targetPerSet = 4;
            const eventsBySet = {};

            for (const evt of allEvents) {
                if (evt.score >= baseThreshold) {
                    if (!eventsBySet[evt.set_number]) {
                        eventsBySet[evt.set_number] = [];
                    }
                    eventsBySet[evt.set_number].push(evt);
                }
            }

            // Take top N per set by score
            for (const setNum in eventsBySet) {
                eventsBySet[setNum].sort((a, b) => b.score - a.score);
                const topEvents = eventsBySet[setNum].slice(0, targetPerSet);
                playerHighlights.push(...topEvents);
            }

            // Sort final list by time for navigation
            playerHighlights.sort((a, b) => a.time - b.time);
            document.getElementById('highlightCount').textContent = `${playerHighlights.length} highlights`;
        }

        function nextHighlight() {
            if (playerHighlights.length === 0) return;

            const currentTime = getCurrentTime();
            let nextIndex;

            // If near last highlight, go to next
            if (lastHighlightIndex >= 0 && lastHighlightIndex < playerHighlights.length - 1) {
                const lastTime = playerHighlights[lastHighlightIndex].time;
                if (Math.abs(currentTime - (lastTime - HIGHLIGHT_SEEK_BUFFER)) < 3) {
                    nextIndex = lastHighlightIndex + 1;
                }
            }

            // Otherwise find based on current time
            if (nextIndex === undefined) {
                for (let i = 0; i < playerHighlights.length; i++) {
                    if (playerHighlights[i].time > currentTime + 0.5) {
                        nextIndex = i;
                        break;
                    }
                }
            }

            if (nextIndex !== undefined && nextIndex < playerHighlights.length) {
                lastHighlightIndex = nextIndex;
                seekTo(playerHighlights[nextIndex].time - HIGHLIGHT_SEEK_BUFFER);
                if (player) player.playVideo();
            }
        }

        function prevHighlight() {
            if (playerHighlights.length === 0) return;

            const currentTime = getCurrentTime();

            // If near last highlight, replay or go to previous
            if (lastHighlightIndex >= 0) {
                const lastTime = playerHighlights[lastHighlightIndex].time;

                // If past the event, replay it
                if (currentTime > lastTime - 0.5) {
                    seekTo(lastTime - HIGHLIGHT_SEEK_BUFFER);
                    if (player) player.playVideo();
                    return;
                }

                // If near the start, go to previous
                if (Math.abs(currentTime - (lastTime - HIGHLIGHT_SEEK_BUFFER)) < 2 && lastHighlightIndex > 0) {
                    lastHighlightIndex--;
                    seekTo(playerHighlights[lastHighlightIndex].time - HIGHLIGHT_SEEK_BUFFER);
                    if (player) player.playVideo();
                    return;
                }
            }

            // Otherwise find based on current time
            for (let i = playerHighlights.length - 1; i >= 0; i--) {
                if (playerHighlights[i].time < currentTime - 1) {
                    lastHighlightIndex = i;
                    seekTo(playerHighlights[i].time - HIGHLIGHT_SEEK_BUFFER);
                    if (player) player.playVideo();
                    return;
                }
            }
        }

        // Load chapters from JSON
        function loadChaptersFromJSON(data) {
            chapters = data.chapters || [];

            // Build flat list of queen kills from all chapters
            queenKills = [];
            for (const ch of chapters) {
                if (ch.queen_kills) {
                    for (const qk of ch.queen_kills) {
                        queenKills.push({
                            time: qk.time,
                            victim: qk.victim,
                            game_id: ch.game_id
                        });
                    }
                }
            }
            // Sort by time (should already be sorted, but ensure it)
            queenKills.sort((a, b) => a.time - b.time);

            renderChapters();
            updateCurrentChapter();
            console.log(`Loaded ${chapters.length} chapters with ${queenKills.length} queen kills`);
            if (chapters.length > 0) {
                console.log(`First chapter at ${chapters[0].start_time}s, last at ${chapters[chapters.length-1].start_time}s`);
            }
        }

        // Event listeners
        document.getElementById('prevChapter').addEventListener('click', prevChapter);
        document.getElementById('nextChapter').addEventListener('click', nextChapter);
        playPauseBtn.addEventListener('click', togglePlayPause);

        chapterFilter.addEventListener('input', (e) => {
            renderChapters(e.target.value);
        });

        // Position selector
        document.getElementById('positionSelect').addEventListener('change', (e) => {
            selectedPosition = e.target.value;
            updatePlayerHighlights();
            renderChapters(chapterFilter.value);  // Re-render to show player dots on plots
            // Sync mobile selector
            document.getElementById('mobilePositionSelect').value = selectedPosition;
            document.getElementById('mobileHighlightCount').textContent =
                playerHighlights.length ? `${playerHighlights.length} highlights` : '';
        });

        // Mobile controls
        let mobileControlsVisible = true;

        document.getElementById('mobileToggle').addEventListener('click', () => {
            mobileControlsVisible = !mobileControlsVisible;
            document.getElementById('mobileControls').classList.toggle('visible', mobileControlsVisible);
            document.getElementById('mobileToggle').textContent = mobileControlsVisible ? '✕' : '☰';
        });

        document.getElementById('mPrevSet').addEventListener('click', prevSet);
        document.getElementById('mNextSet').addEventListener('click', nextSet);
        document.getElementById('mPrevGame').addEventListener('click', prevChapter);
        document.getElementById('mNextGame').addEventListener('click', nextChapter);
        document.getElementById('mPrevHighlight').addEventListener('click', prevHighlight);
        document.getElementById('mNextHighlight').addEventListener('click', nextHighlight);

        document.getElementById('mobilePositionSelect').addEventListener('change', (e) => {
            selectedPosition = e.target.value;
            // Sync desktop selector
            document.getElementById('positionSelect').value = selectedPosition;
            updatePlayerHighlights();
            renderChapters(chapterFilter.value);
            document.getElementById('mobileHighlightCount').textContent =
                playerHighlights.length ? `${playerHighlights.length} highlights` : '';
        });

        // File loading (hidden input, kept for flexibility)
        document.getElementById('chaptersInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        loadChaptersFromJSON(data);
                    } catch (err) {
                        alert('Error parsing chapters.json: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT') return;

            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlayPause();
                    break;
                case 'ArrowLeft':
                    seekTo(getCurrentTime() - 5);
                    break;
                case 'ArrowRight':
                    seekTo(getCurrentTime() + 5);
                    break;
                case 'j':
                    seekTo(getCurrentTime() - 10);
                    break;
                case 'l':
                    seekTo(getCurrentTime() + 10);
                    break;
                case 'p':
                    prevChapter();
                    break;
                case 'n':
                    nextChapter();
                    break;
                case 'g':
                    nextChapter();
                    break;
                case 'G':
                    prevChapter();
                    break;
                case 's':
                    nextSet();
                    break;
                case 'S':
                    prevSet();
                    break;
                case 'e':
                    nextQueenKill();
                    break;
                case 'E':
                    prevQueenKill();
                    break;
                case 'h':
                    nextHighlight();
                    break;
                case 'H':
                    prevHighlight();
                    break;
                case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9': case '0':
                    // Map keyboard to internal position IDs (viewer perspective)
                    const keyToPosition = {
                        '1': '10',  // Blue Checkers
                        '2': '8',   // Blue Skull
                        '3': '2',   // Blue Queen
                        '4': '9',   // Blue Abs
                        '5': '7',   // Blue Stripes
                        '6': '6',   // Gold Checkers
                        '7': '4',   // Gold Skull
                        '8': '1',   // Gold Queen
                        '9': '5',   // Gold Abs
                        '0': '3',   // Gold Stripes
                    };
                    const posSelect = document.getElementById('positionSelect');
                    posSelect.value = keyToPosition[e.key];
                    selectedPosition = keyToPosition[e.key];
                    updatePlayerHighlights();
                    renderChapters(chapterFilter.value);  // Re-render to show player dots on plots
                    // Sync mobile selector
                    document.getElementById('mobilePositionSelect').value = selectedPosition;
                    document.getElementById('mobileHighlightCount').textContent =
                        playerHighlights.length ? `${playerHighlights.length} highlights` : '';
                    break;
            }
        });

        // Try to auto-load chapters.json from same directory
        fetch('chapters.json')
            .then(r => r.json())
            .then(loadChaptersFromJSON)
            .catch(() => console.log('No chapters.json found, load manually'));
    </script>
</body>
</html>
