<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KQ Video Player</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #eee;
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .video-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            flex-shrink: 0;
        }

        #player {
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #242424;
            border-radius: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .controls button {
            background: #3d3d3d;
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .controls button:hover {
            background: #e94560;
        }

        .controls button:disabled {
            background: #333;
            cursor: not-allowed;
        }

        .time-display {
            font-family: monospace;
            font-size: 14px;
            color: #aaa;
        }

        .nav-group {
            display: inline-flex;
            gap: 2px;
            background: #333;
            border-radius: 5px;
            padding: 2px;
        }

        .nav-group button {
            padding: 8px 12px;
            font-size: 12px;
        }

        .current-chapter {
            padding: 10px 15px;
            background: #242424;
            border-radius: 8px;
            margin-top: 10px;
        }

        .current-chapter h3 {
            color: #e94560;
            margin-bottom: 5px;
        }

        .chapter-sidebar {
            width: 350px;
            background: #242424;
            overflow-y: auto;
            border-left: 1px solid #333333;
        }

        .sidebar-header {
            padding: 20px;
            background: #2d2d2d;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sidebar-header h2 {
            margin-bottom: 10px;
        }

        .sidebar-header input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            background: #1a1a1a;
            color: #fff;
            font-size: 14px;
        }

        .position-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }

        .position-selector label {
            font-size: 13px;
            color: #aaa;
        }

        .position-selector select {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            background: #1a1a1a;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
        }

        #highlightCount {
            font-size: 12px;
            color: #e94560;
            font-weight: 600;
        }

        .win-prob-plot {
            width: 100%;
            height: 40px;
            margin-top: 6px;
            background: #1a1a1a;
            border-radius: 4px;
            cursor: pointer;
        }

        .win-prob-plot:hover {
            background: #252545;
        }

        .win-prob-plot svg {
            width: 100%;
            height: 100%;
        }

        .chapter-list {
            padding: 10px;
        }

        .chapter-item {
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 4px;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .chapter-item:hover {
            background: #383838;
        }

        .chapter-item.active {
            background: #383838;
            border-left-color: #e94560;
        }

        .chapter-item.gold-win {
            border-right: 3px solid #ffd700;
        }

        .chapter-item.blue-win {
            border-right: 3px solid #5ba3ec;
        }

        /* Set styling */
        .chapter-item.set-start {
            margin-top: 16px;
            padding: 14px;
            background: #2d2d2d;
            border-left: 3px solid #e94560;
        }

        .chapter-item.set-start:first-child {
            margin-top: 0;
        }

        .chapter-item.in-set {
            margin-left: 20px;
            padding: 8px 12px;
            font-size: 0.9em;
            opacity: 0.85;
        }

        .chapter-item.in-set .chapter-title {
            font-size: 0.95em;
        }

        .chapter-item.in-set .chapter-time,
        .chapter-item.in-set .chapter-meta {
            font-size: 11px;
        }

        .set-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #e94560;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .chapter-time {
            font-family: monospace;
            font-size: 12px;
            color: #888;
            margin-bottom: 4px;
        }

        .chapter-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .chapter-meta {
            font-size: 12px;
            color: #aaa;
        }

        .chapter-meta .winner {
            font-weight: 600;
        }

        .chapter-meta .gold, .set-label .gold { color: #ffd700; }
        .chapter-meta .blue, .set-label .blue { color: #5ba3ec; }

        .kd-stats {
            color: #e94560;
            font-weight: 600;
        }

        .good-prob {
            color: #4caf50;
            font-weight: 600;
        }

        .bad-prob {
            color: #f44336;
            font-weight: 600;
        }

        .load-section {
            padding: 20px;
            text-align: center;
        }

        .keyboard-hints {
            font-size: 15px;
            font-weight: 600;
            color: #aaa;
            margin-top: 10px;
            line-height: 1.8;
        }

        .keyboard-hints kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
        }

        .highlight-debug {
            margin-top: 15px;
            padding: 12px;
            background: #242424;
            max-height: 200px;
            overflow-y: auto;
            border-radius: 8px;
            font-size: 13px;
        }

        .highlight-debug h4 {
            margin: 0 0 10px 0;
            color: #e94560;
            font-size: 14px;
        }

        .highlight-debug-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 8px;
            margin-bottom: 4px;
            background: #1a1a1a;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .highlight-debug-item:hover {
            background: #333;
        }

        .highlight-debug-item.active {
            background: #3d3d3d;
            border-left: 3px solid #e94560;
            padding-left: 5px;
        }

        .highlight-debug-pos {
            display: flex;
            align-items: center;
            min-width: 18px;
        }

        .highlight-debug-time {
            font-family: monospace;
            color: #5ba3ec;
            min-width: 60px;
        }

        .highlight-debug-delta {
            font-weight: 600;
            min-width: 50px;
        }

        .highlight-debug-delta.positive {
            color: #4caf50;
        }

        .highlight-debug-delta.negative {
            color: #f44336;
        }

        .highlight-debug-type {
            color: #aaa;
            font-size: 12px;
        }

        .highlight-debug-game {
            color: #888;
            font-size: 11px;
            margin-left: auto;
        }

        .highlight-debug-empty {
            color: #666;
            font-style: italic;
        }

        .highlight-debug-values {
            font-family: monospace;
            font-size: 11px;
            color: #888;
            padding: 2px 8px 6px 68px;
            margin-top: -4px;
            margin-bottom: 4px;
        }

        /* Mobile styles - use pointer:coarse to detect touch devices */
        @media (pointer: coarse), (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .chapter-sidebar {
                display: none;
            }

            .video-section {
                height: 100vh;
                padding: 10px;
            }

            .keyboard-hints {
                display: none;
            }

            .controls {
                display: none;
            }

            .current-chapter {
                display: none;
            }

            .highlight-debug {
                display: none;
            }

            .mobile-toggle {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 44px;
                height: 44px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.2);
                border: 1px solid rgba(255, 255, 255, 0.3);
                color: white;
                font-size: 22px;
                z-index: 100;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }

            .mobile-controls {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                padding: 12px;
                transform: translateY(100%);
                transition: transform 0.3s ease;
                z-index: 99;
            }

            .mobile-controls.visible {
                transform: translateY(0);
            }

            .mobile-nav-row {
                display: flex;
                justify-content: center;
                gap: 8px;
                margin-bottom: 10px;
            }

            .nav-group-left, .nav-group-right {
                display: flex;
                gap: 6px;
                background: rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(4px);
                -webkit-backdrop-filter: blur(4px);
                padding: 8px;
                border-radius: 8px;
            }

            .mobile-nav-row button {
                padding: 10px 10px;
                font-size: 13px;
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                border-radius: 6px;
                cursor: pointer;
            }

            .mobile-nav-row button:active {
                background: rgba(255, 255, 255, 0.3);
            }

            .mobile-select {
                padding: 10px;
                font-size: 14px;
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                border-radius: 6px;
                max-width: 120px;
            }

            /* Landscape: side controls */
            @media (orientation: landscape) {
                .mobile-controls {
                    top: 0;
                    background: transparent;
                    padding: 0;
                    pointer-events: none;
                }

                .mobile-controls.visible {
                    transform: none;
                }

                .mobile-nav-row {
                    position: static;
                    pointer-events: none;
                }

                .nav-group-left {
                    position: fixed;
                    left: 8px;
                    top: 50%;
                    transform: translateY(-50%);
                    flex-direction: column;
                    gap: 8px;
                    pointer-events: auto;
                }

                .nav-group-right {
                    position: fixed;
                    right: 8px;
                    top: 50%;
                    transform: translateY(-50%);
                    flex-direction: column;
                    gap: 8px;
                    pointer-events: auto;
                }

                .mobile-toggle {
                    top: 8px;
                    bottom: auto;
                }
            }

        }

        /* Hide mobile elements on desktop (non-touch devices above 768px) */
        @media (pointer: fine) and (min-width: 769px) {
            .mobile-toggle, .mobile-controls {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-section">
            <div class="video-wrapper">
                <div id="player"></div>
            </div>

            <div class="controls">
                <button id="playPause">‚ñ∂ Play</button>
                <span class="time-display" id="timeDisplay">0:00 / 0:00</span>
                <span class="nav-group">
                    <button id="prevSet" title="Previous set (Shift+S)">‚óÄSet</button>
                    <button id="nextSet" title="Next set (S)">Set‚ñ∂</button>
                </span>
                <span class="nav-group">
                    <button id="prevChapter" title="Previous game (Shift+G)">‚óÄGame</button>
                    <button id="nextChapter" title="Next game (G)">Game‚ñ∂</button>
                </span>
                <span class="nav-group">
                    <button id="prevEgg" title="Previous queen kill (Shift+E)">‚óÄEgg</button>
                    <button id="nextEgg" title="Next queen kill (E)">Egg‚ñ∂</button>
                </span>
                <span class="nav-group">
                    <button id="prevHighlightBtn" title="Previous highlight (Shift+H)">‚óÄHL</button>
                    <button id="nextHighlightBtn" title="Next highlight (H)">HL‚ñ∂</button>
                </span>
            </div>

            <div class="current-chapter" id="currentChapterInfo">
            </div>

            <div class="keyboard-hints">
                <kbd>‚Üê</kbd><kbd>‚Üí</kbd> Seek 5s &nbsp;
                <kbd>J</kbd><kbd>L</kbd> Seek 10s &nbsp;
                <kbd>Space</kbd> Play/Pause<br>
                <kbd>G</kbd> Game (Shift: prev) &nbsp;
                <kbd>S</kbd> Set (Shift: prev) &nbsp;
                <kbd>E</kbd> Egg/queen kill (Shift: prev)<br>
                <kbd>1</kbd>-<kbd>0</kbd> Select position &nbsp;
                <kbd>H</kbd> Player highlight (Shift: prev)
            </div>

            <div class="highlight-debug" id="highlightDebug">
            </div>
        </div>

        <div class="chapter-sidebar">
            <div class="sidebar-header">
                <h2>Chapters</h2>
                <input type="text" id="chapterFilter" placeholder="Filter by map, winner...">
                <div class="position-selector">
                    <label for="playerSelect">Player:</label>
                    <select id="playerSelect">
                        <option value="">Select player...</option>
                    </select>
                </div>
                <div class="position-selector">
                    <label for="positionSelect">Position:</label>
                    <select id="positionSelect">
                        <option value="">Or by position...</option>
                        <option value="10">1 - ‚ñ¶ Blue Checkers</option>
                        <option value="8">2 - üíÄ Blue Skull</option>
                        <option value="2">3 - üëë Blue Queen</option>
                        <option value="9">4 - üí™ Blue Abs</option>
                        <option value="7">5 - ‚ò∞ Blue Stripes</option>
                        <option value="6">6 - ‚ñ¶ Gold Checkers</option>
                        <option value="4">7 - üíÄ Gold Skull</option>
                        <option value="1">8 - üëë Gold Queen</option>
                        <option value="5">9 - üí™ Gold Abs</option>
                        <option value="3">0 - ‚ò∞ Gold Stripes</option>
                    </select>
                    <span id="highlightCount"></span>
                </div>
            </div>
            <div class="chapter-list" id="chapterList">
            </div>
        </div>
    </div>

    <!-- Mobile toggle button -->
    <button class="mobile-toggle" id="mobileToggle">‚úï</button>

    <!-- Mobile control bar -->
    <div class="mobile-controls visible" id="mobileControls">
        <div class="mobile-nav-row">
            <div class="nav-group-left">
                <button id="mPrevSet">‚óÄ‚óÄ S</button>
                <button id="mPrevGame">‚óÄ G</button>
                <button id="mPrevHighlight">‚óÄ H</button>
                <select id="mobilePlayerSelect" class="mobile-select">
                    <option value="">Player...</option>
                </select>
            </div>
            <div class="nav-group-right">
                <button id="mNextSet">S ‚ñ∂‚ñ∂</button>
                <button id="mNextGame">G ‚ñ∂</button>
                <button id="mNextHighlight">H ‚ñ∂</button>
                <select id="mobilePositionSelect" class="mobile-select">
                    <option value="">Position...</option>
                    <option value="10">1 ‚ñ¶ Blue Chk</option>
                    <option value="8">2 üíÄ Blue Skl</option>
                    <option value="2">3 üëë Blue Qn</option>
                    <option value="9">4 üí™ Blue Abs</option>
                    <option value="7">5 ‚ò∞ Blue Str</option>
                    <option value="6">6 ‚ñ¶ Gold Chk</option>
                    <option value="4">7 üíÄ Gold Skl</option>
                    <option value="1">8 üëë Gold Qn</option>
                    <option value="5">9 üí™ Gold Abs</option>
                    <option value="3">0 ‚ò∞ Gold Str</option>
                </select>
            </div>
        </div>
    </div>

    <input type="file" id="chaptersInput" accept=".json" style="display: none;">

    <!-- YouTube IFrame API -->
    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        const chapterList = document.getElementById('chapterList');
        const currentChapterInfo = document.getElementById('currentChapterInfo');
        const timeDisplay = document.getElementById('timeDisplay');
        const chapterFilter = document.getElementById('chapterFilter');
        const playPauseBtn = document.getElementById('playPause');

        let player;
        let chapters = [];
        let queenKills = [];  // Flat list of all queen kill timestamps
        let currentChapterIndex = -1;
        let lastQueenKillIndex = -1;  // Track last navigated queen kill
        let timeUpdateInterval;

        // Player highlight state
        let selectedPosition = null;
        let playerHighlights = [];  // Filtered events for selected position
        let lastHighlightIndex = -1;

        // Tournament user data
        let users = {};  // user_id -> {name, scene}
        let selectedUserId = null;  // Currently selected user

        // Seconds to seek before a highlight event
        const HIGHLIGHT_SEEK_BUFFER = 4.5;

        // Position names and icons for each character
        const POSITION_NAMES = {
            '1': 'Gold Queen', '2': 'Blue Queen',
            '3': 'Gold Stripes', '4': 'Gold Skull', '5': 'Gold Abs', '6': 'Gold Checkers',
            '7': 'Blue Stripes', '8': 'Blue Skull', '9': 'Blue Abs', '10': 'Blue Checkers'
        };

        // Emoji icons (for dropdowns where we can't use HTML)
        const POSITION_ICONS = {
            '1': 'üëë',   // Gold Queen
            '2': 'üëë',   // Blue Queen
            '3': '‚ò∞',    // Gold Stripes (trigram)
            '4': 'üíÄ',   // Gold Skull
            '5': 'üí™',   // Gold Abs
            '6': '‚ñ¶',    // Gold Checkers
            '7': '‚ò∞',    // Blue Stripes
            '8': 'üíÄ',   // Blue Skull
            '9': 'üí™',   // Blue Abs
            '10': '‚ñ¶'    // Blue Checkers
        };

        // SVG icons for each position type (allows colored images)
        const GOLD_COLOR = '#ffc107';
        const BLUE_COLOR = '#2196f3';
        const DARK_BG = '#1a1a1a';

        // SVG templates for each character type (using encodeURIComponent for proper encoding)
        const SVG_TEMPLATES = {
            // Crown for queens
            crown: (color) => `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${color}"><path d="M5 16L3 5l5.5 5L12 4l3.5 6L21 5l-2 11H5zm14 3c0 .6-.4 1-1 1H6c-.6 0-1-.4-1-1v-1h14v1z"/></svg>`)}`,
            // Horizontal stripes
            stripes: (color) => `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${color}"><rect x="3" y="4" width="18" height="3" rx="1"/><rect x="3" y="10" width="18" height="3" rx="1"/><rect x="3" y="16" width="18" height="3" rx="1"/></svg>`)}`,
            // Skull
            skull: (color) => `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${color}"><path d="M12 2C6.5 2 2 6.5 2 12v3.5c0 1.4 1.1 2.5 2.5 2.5H6v-3h2v4h3v-4h2v4h3v-4h2v3h1.5c1.4 0 2.5-1.1 2.5-2.5V12c0-5.5-4.5-10-10-10zm-3 12a2 2 0 110-4 2 2 0 010 4zm6 0a2 2 0 110-4 2 2 0 010 4z"/></svg>`)}`,
            // Abs/muscular figure
            abs: (color) => `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${color}"><ellipse cx="12" cy="5" rx="4" ry="3"/><path d="M8 9h8v13H8V9z"/><rect x="9" y="10" width="2.5" height="3" fill="${DARK_BG}"/><rect x="12.5" y="10" width="2.5" height="3" fill="${DARK_BG}"/><rect x="9" y="14" width="2.5" height="3" fill="${DARK_BG}"/><rect x="12.5" y="14" width="2.5" height="3" fill="${DARK_BG}"/><rect x="9" y="18" width="2.5" height="2.5" fill="${DARK_BG}"/><rect x="12.5" y="18" width="2.5" height="2.5" fill="${DARK_BG}"/></svg>`)}`,
            // Checkerboard pattern
            checkers: (color) => `data:image/svg+xml,${encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect width="24" height="24" fill="${color}"/><rect x="0" y="0" width="6" height="6" fill="${DARK_BG}"/><rect x="12" y="0" width="6" height="6" fill="${DARK_BG}"/><rect x="6" y="6" width="6" height="6" fill="${DARK_BG}"/><rect x="18" y="6" width="6" height="6" fill="${DARK_BG}"/><rect x="0" y="12" width="6" height="6" fill="${DARK_BG}"/><rect x="12" y="12" width="6" height="6" fill="${DARK_BG}"/><rect x="6" y="18" width="6" height="6" fill="${DARK_BG}"/><rect x="18" y="18" width="6" height="6" fill="${DARK_BG}"/></svg>`)}`
        };

        // SVG data URLs for each position
        const POSITION_SVGS = {
            '1': SVG_TEMPLATES.crown(GOLD_COLOR),    // Gold Queen
            '2': SVG_TEMPLATES.crown(BLUE_COLOR),    // Blue Queen
            '3': SVG_TEMPLATES.stripes(GOLD_COLOR),  // Gold Stripes
            '4': SVG_TEMPLATES.skull(GOLD_COLOR),    // Gold Skull
            '5': SVG_TEMPLATES.abs(GOLD_COLOR),      // Gold Abs
            '6': SVG_TEMPLATES.checkers(GOLD_COLOR), // Gold Checkers
            '7': SVG_TEMPLATES.stripes(BLUE_COLOR),  // Blue Stripes
            '8': SVG_TEMPLATES.skull(BLUE_COLOR),    // Blue Skull
            '9': SVG_TEMPLATES.abs(BLUE_COLOR),      // Blue Abs
            '10': SVG_TEMPLATES.checkers(BLUE_COLOR) // Blue Checkers
        };

        // Create an img element with the position's SVG icon
        function getPositionIconImg(pos, size = 18) {
            if (!POSITION_SVGS[pos]) return '';
            return `<img src="${POSITION_SVGS[pos]}" width="${size}" height="${size}" style="vertical-align: middle; margin-right: 4px;" alt="${POSITION_NAMES[pos] || 'Position'}">`;
        }

        // Get display string for a position (icon + name)
        function getPositionDisplay(pos, includeIcon = true, useImage = false) {
            const name = POSITION_NAMES[pos] || `Position ${pos}`;
            if (includeIcon) {
                if (useImage && POSITION_SVGS[pos]) {
                    return getPositionIconImg(pos) + name;
                } else if (POSITION_ICONS[pos]) {
                    return `${POSITION_ICONS[pos]} ${name}`;
                }
            }
            return name;
        }

        // Video ID from chapters data
        let videoId = null;
        let youtubeApiReady = false;

        // Initialize YouTube player (called when both API and chapters are ready)
        function initializePlayer() {
            if (!youtubeApiReady || !videoId || player) return;

            player = new YT.Player('player', {
                videoId: videoId,
                playerVars: {
                    'autoplay': 0,
                    'controls': 1,
                    'rel': 0,
                    'modestbranding': 1,
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        // Called by YouTube API when ready
        function onYouTubeIframeAPIReady() {
            youtubeApiReady = true;
            initializePlayer();
        }

        function onPlayerReady(event) {
            console.log('YouTube player ready');
            // Start time update interval
            timeUpdateInterval = setInterval(updateCurrentChapter, 500);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseBtn.textContent = '‚è∏ Pause';
            } else {
                playPauseBtn.textContent = '‚ñ∂ Play';
            }
        }

        // Get current time from YouTube player
        function getCurrentTime() {
            return player && player.getCurrentTime ? player.getCurrentTime() : 0;
        }

        // Get video duration
        function getDuration() {
            return player && player.getDuration ? player.getDuration() : 0;
        }

        // Seek to time
        function seekTo(seconds) {
            if (player && player.seekTo) {
                player.seekTo(seconds, true);
            }
        }

        // Play/Pause
        function togglePlayPause() {
            if (!player) return;
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        // Format time as M:SS or H:MM:SS
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) {
                return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Find chapter at current time
        function findChapterAtTime(time) {
            for (let i = chapters.length - 1; i >= 0; i--) {
                if (time >= chapters[i].start_time) {
                    return i;
                }
            }
            return -1;
        }

        // Update current chapter display
        function updateCurrentChapter() {
            const currentTime = getCurrentTime();
            const newIndex = findChapterAtTime(currentTime);

            if (newIndex !== currentChapterIndex) {
                currentChapterIndex = newIndex;

                // If user is selected, update selectedPosition for this chapter
                if (selectedUserId && currentChapterIndex >= 0) {
                    const pos = getUserPositionInChapter(selectedUserId, chapters[currentChapterIndex]);
                    selectedPosition = pos ? String(pos) : null;
                }

                // Update sidebar highlighting
                document.querySelectorAll('.chapter-item').forEach((el, i) => {
                    el.classList.toggle('active', i === currentChapterIndex);
                });

                // Scroll active chapter into view
                const activeEl = document.querySelector('.chapter-item.active');
                if (activeEl) {
                    activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            // Update info panel
            if (currentChapterIndex >= 0) {
                const ch = chapters[currentChapterIndex];
                currentChapterInfo.innerHTML = `
                    <h3>${ch.title}</h3>
                    <p>
                        <span class="${ch.winner}">${ch.winner}</span> wins by ${ch.win_condition}
                        &nbsp;|&nbsp; Duration: ${formatTime(ch.duration)}
                        &nbsp;|&nbsp; <a href="${ch.hivemind_url}" target="_blank" style="color: #e94560;">HiveMind</a>
                    </p>
                `;
            }

            // Update time display
            timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(getDuration())}`;
        }

        // Calculate net win probability change for a player in a chapter
        function calculateNetWinProb(ch, positionId) {
            if (!positionId || !ch.player_events) return null;
            const pos = parseInt(positionId);
            let netDelta = 0;

            for (const evt of ch.player_events) {
                if (evt.positions && evt.positions.includes(pos)) {
                    netDelta += evt.delta;
                }
            }

            return netDelta;
        }

        // Find high-impact time ranges for a player in a chapter
        function findHighImpactRanges(ch, positionId) {
            if (!positionId || !ch.player_events) return [];
            const pos = parseInt(positionId);

            // Get all events for this player sorted by time
            const playerEvents = ch.player_events
                .filter(evt => evt.positions && evt.positions.includes(pos) && Math.abs(evt.delta) >= 0.05)
                .sort((a, b) => a.time - b.time);

            if (playerEvents.length === 0) return [];

            // Cluster nearby events (within 5 seconds)
            const ranges = [];
            let rangeStart = null;
            let rangeEnd = null;
            let rangeDelta = 0;

            for (const evt of playerEvents) {
                if (rangeStart === null) {
                    rangeStart = evt.time;
                    rangeEnd = evt.time;
                    rangeDelta = evt.delta;
                } else if (evt.time - rangeEnd <= 5) {
                    rangeEnd = evt.time;
                    rangeDelta += evt.delta;
                } else {
                    if (Math.abs(rangeDelta) >= 0.10) {
                        ranges.push({ start: rangeStart, end: rangeEnd, delta: rangeDelta });
                    }
                    rangeStart = evt.time;
                    rangeEnd = evt.time;
                    rangeDelta = evt.delta;
                }
            }
            // Don't forget the last range
            if (rangeStart !== null && Math.abs(rangeDelta) >= 0.10) {
                ranges.push({ start: rangeStart, end: rangeEnd, delta: rangeDelta });
            }

            return ranges;
        }

        // Calculate K/D stats for a chapter and selected position
        function calculateKD(ch, positionId) {
            if (!positionId || !ch.kill_events) return null;
            const pos = parseInt(positionId);
            let kills = 0;
            let deaths = 0;

            for (const evt of ch.kill_events) {
                if (evt.killer === pos) kills++;
                if (evt.victim === pos) deaths++;
            }

            return { kills, deaths };
        }

        // Check if a position is on the gold team
        function isGoldTeam(positionId) {
            const pos = parseInt(positionId);
            // Gold: odd positions (1, 3, 5, 7, 9)
            // Blue: even positions (2, 4, 6, 8, 10)
            return pos % 2 === 1;
        }

        // Render win probability plot for a chapter
        function renderWinProbPlot(ch, index) {
            if (!ch.win_timeline || ch.win_timeline.length < 2) return '';

            const width = 280;
            const height = 36;
            const padding = 2;

            const timeline = ch.win_timeline;
            const startTime = ch.start_time;
            const endTime = ch.end_time;
            const duration = endTime - startTime;

            // Get position for this chapter (may vary if user is selected)
            let chapterPosition = selectedPosition;
            if (selectedUserId) {
                const pos = getUserPositionInChapter(selectedUserId, ch);
                chapterPosition = pos ? String(pos) : null;
            }

            // Determine if we need to flip perspective for gold team
            const flipForGold = chapterPosition && isGoldTeam(chapterPosition);

            // Find high-impact ranges for selected player
            const highImpactRanges = chapterPosition ? findHighImpactRanges(ch, chapterPosition) : [];

            // Create highlight rectangles for high-impact ranges
            // Green = good for player's team, Red = bad for player's team
            const highlightsHtml = highImpactRanges.map(range => {
                const x1 = padding + ((range.start - startTime) / duration) * (width - 2 * padding);
                const x2 = padding + ((range.end - startTime) / duration) * (width - 2 * padding);
                const rangeWidth = Math.max(x2 - x1, 6); // Minimum width of 6px
                // For blue player: positive delta = good (green)
                // For gold player: negative delta = good (green) because delta is from blue's perspective
                const isGoodForPlayer = flipForGold ? range.delta < 0 : range.delta > 0;
                const color = isGoodForPlayer ? 'rgba(76, 175, 80, 0.4)' : 'rgba(244, 67, 54, 0.4)';
                return `<rect x="${x1 - 2}" y="0" width="${rangeWidth + 4}" height="${height}" fill="${color}"/>`;
            }).join('');

            // Build SVG path for win probability line
            let pathD = '';

            for (let i = 0; i < timeline.length; i++) {
                const pt = timeline[i];
                const x = padding + ((pt.t - startTime) / duration) * (width - 2 * padding);
                // Flip probability for gold team perspective
                const prob = flipForGold ? (1 - pt.p) : pt.p;
                const y = height - padding - (prob * (height - 2 * padding));

                if (i === 0) {
                    pathD += `M ${x} ${y}`;
                } else {
                    pathD += ` L ${x} ${y}`;
                }
            }

            return `
                <div class="win-prob-plot" data-chapter="${index}">
                    <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
                        ${highlightsHtml}
                        <line x1="${padding}" y1="${height/2}" x2="${width-padding}" y2="${height/2}"
                              stroke="#333" stroke-width="1" stroke-dasharray="2,2"/>
                        <path d="${pathD}" fill="none" stroke="#888" stroke-width="1.5"/>
                    </svg>
                </div>
            `;
        }

        // Render chapter list
        function renderChapters(filter = '') {
            const filterLower = filter.toLowerCase();

            chapterList.innerHTML = chapters
                .map((ch, i) => {
                    // Calculate player's position in this chapter first (needed for filtering)
                    let chapterPosition = selectedPosition;
                    if (selectedUserId) {
                        const pos = getUserPositionInChapter(selectedUserId, ch);
                        chapterPosition = pos ? String(pos) : null;
                    }

                    // Filter by selected player - skip games they're not in
                    if (selectedUserId && !chapterPosition) {
                        return '';
                    }

                    // Filter by text search
                    if (filter) {
                        const searchText = `${ch.map} ${ch.winner} ${ch.win_condition} ${ch.game_id}`.toLowerCase();
                        if (!searchText.includes(filterLower)) {
                            return '';
                        }
                    }

                    const winnerClass = ch.winner === 'gold' ? 'gold-win' : 'blue-win';
                    const activeClass = i === currentChapterIndex ? 'active' : '';
                    const setClass = ch.is_set_start ? 'set-start' : 'in-set';
                    const setLabel = ch.is_set_start && ch.match_info ?
                        `<div class="set-label"><span class="blue">${ch.match_info.blue}</span> vs <span class="gold">${ch.match_info.gold}</span></div>` : '';

                    const plotHtml = renderWinProbPlot(ch, i);

                    // Calculate K/D and net win prob for selected player
                    let statsHtml = '';
                    if (chapterPosition) {
                        const kd = calculateKD(ch, chapterPosition);
                        const netProb = calculateNetWinProb(ch, chapterPosition);
                        if (kd) {
                            // Flip net prob for gold team (delta is from blue's perspective)
                            const playerNetProb = isGoldTeam(chapterPosition) ? -netProb : netProb;
                            const netProbStr = playerNetProb !== null ?
                                `<span class="${playerNetProb >= 0 ? 'good-prob' : 'bad-prob'}">${playerNetProb >= 0 ? '+' : ''}${(playerNetProb * 100).toFixed(0)}%</span>` : '';
                            statsHtml = `<span class="kd-stats">${kd.kills}/${kd.deaths}</span> ${netProbStr}`;
                        }
                    }

                    return `
                        <div class="chapter-item ${winnerClass} ${activeClass} ${setClass}" data-index="${i}">
                            ${setLabel}
                            <div class="chapter-title">${ch.title}</div>
                            <div class="chapter-meta">
                                <span class="winner ${ch.winner}">${ch.winner}</span> ${ch.win_condition}
                                &nbsp;|&nbsp; ${formatTime(ch.duration)}
                                ${statsHtml ? '&nbsp;|&nbsp;' + statsHtml : ''}
                            </div>
                            ${plotHtml}
                        </div>
                    `;
                })
                .join('');

            // Add click handlers for chapter items (not on plot)
            document.querySelectorAll('.chapter-item').forEach(el => {
                el.addEventListener('click', (e) => {
                    // Don't trigger if clicking on plot
                    if (e.target.closest('.win-prob-plot')) return;
                    const index = parseInt(el.dataset.index);
                    jumpToChapter(index);
                });
            });

            // Add click handlers for plots (seek to specific time)
            document.querySelectorAll('.win-prob-plot').forEach(plot => {
                plot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const chapterIndex = parseInt(plot.dataset.chapter);
                    const ch = chapters[chapterIndex];
                    const rect = plot.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / rect.width;
                    const targetTime = ch.start_time + clickX * (ch.end_time - ch.start_time);
                    seekTo(targetTime);
                    if (player) player.playVideo();
                });
            });
        }

        // Jump to chapter
        function jumpToChapter(index) {
            if (index >= 0 && index < chapters.length) {
                const targetTime = chapters[index].start_time;
                console.log(`Jumping to chapter ${index}: ${chapters[index].title} at ${targetTime}s`);
                seekTo(targetTime);
                currentChapterIndex = index;
                updateCurrentChapter();
                if (player) player.playVideo();
            }
        }

        // Navigation
        function prevChapter() {
            const idx = findChapterAtTime(getCurrentTime());
            if (idx > 0) {
                jumpToChapter(idx - 1);
            } else if (idx === 0) {
                jumpToChapter(0);
            }
        }

        function nextChapter() {
            const idx = findChapterAtTime(getCurrentTime());
            if (idx < chapters.length - 1) {
                jumpToChapter(idx + 1);
            } else if (idx === -1 && chapters.length > 0) {
                jumpToChapter(0);
            }
        }

        // Set navigation
        function nextSet() {
            const idx = findChapterAtTime(getCurrentTime());
            for (let i = idx + 1; i < chapters.length; i++) {
                if (chapters[i].is_set_start) {
                    jumpToChapter(i);
                    return;
                }
            }
        }

        function prevSet() {
            const idx = findChapterAtTime(getCurrentTime());
            // If we're past the start of current set's first game, go to current set start
            const currentSetStart = chapters.findIndex((ch, i) =>
                i <= idx && ch.is_set_start &&
                (i === idx || !chapters.slice(i + 1, idx + 1).some(c => c.is_set_start))
            );

            // Find previous set start
            for (let i = idx - 1; i >= 0; i--) {
                if (chapters[i].is_set_start) {
                    // If we're at the start of current set, go to previous set
                    if (i === currentSetStart && getCurrentTime() - chapters[i].start_time < 2) {
                        continue;
                    }
                    jumpToChapter(i);
                    return;
                }
            }
            // If no previous set, go to first chapter
            if (chapters.length > 0) {
                jumpToChapter(0);
            }
        }

        // Queen kill (egg) navigation
        function findQueenKillIndexAtTime(time) {
            // Find the queen kill at or just before the given time
            for (let i = queenKills.length - 1; i >= 0; i--) {
                if (queenKills[i].time <= time + 2) {
                    return i;
                }
            }
            return -1;
        }

        function nextQueenKill() {
            if (queenKills.length === 0) return;

            const currentTime = getCurrentTime();
            let nextIndex;

            // If we're near the last jumped-to kill, go to the next one
            if (lastQueenKillIndex >= 0 && lastQueenKillIndex < queenKills.length - 1) {
                const lastKillTime = queenKills[lastQueenKillIndex].time;
                if (Math.abs(currentTime - (lastKillTime - 1)) < 3) {
                    nextIndex = lastQueenKillIndex + 1;
                }
            }

            // Otherwise find based on current time
            if (nextIndex === undefined) {
                nextIndex = findQueenKillIndexAtTime(currentTime) + 1;
            }

            if (nextIndex < queenKills.length) {
                lastQueenKillIndex = nextIndex;
                seekTo(queenKills[nextIndex].time - 1);
                if (player) player.playVideo();
            }
        }

        function prevQueenKill() {
            if (queenKills.length === 0) return;

            const currentTime = getCurrentTime();

            // If we have a last jumped-to kill, check if we should replay it or go back
            if (lastQueenKillIndex >= 0) {
                const lastKillTime = queenKills[lastQueenKillIndex].time;
                const targetTime = lastKillTime - 1;

                // If we're past the kill moment, replay this kill
                if (currentTime > lastKillTime - 0.5) {
                    seekTo(targetTime);
                    if (player) player.playVideo();
                    return;
                }

                // If we're near the start (within 2s), go to previous kill
                if (Math.abs(currentTime - targetTime) < 2 && lastQueenKillIndex > 0) {
                    lastQueenKillIndex = lastQueenKillIndex - 1;
                    seekTo(queenKills[lastQueenKillIndex].time - 1);
                    if (player) player.playVideo();
                    return;
                }
            }

            // Otherwise find based on current time
            const idx = findQueenKillIndexAtTime(currentTime);
            if (idx >= 0) {
                lastQueenKillIndex = idx;
                seekTo(queenKills[idx].time - 1);
                if (player) player.playVideo();
            }
        }

        // Player highlight functions
        function updatePlayerHighlights() {
            playerHighlights = [];
            lastHighlightIndex = -1;

            // If user is selected, collect events from all their positions across chapters
            // If position is selected, use fixed position
            if (!selectedUserId && !selectedPosition) {
                document.getElementById('highlightCount').innerHTML = '';
                return;
            }

            // Collect all events for this player
            let allEvents = [];
            let anyQueen = false;

            for (const ch of chapters) {
                // Determine position for this chapter
                let pos;
                if (selectedUserId) {
                    pos = getUserPositionInChapter(selectedUserId, ch);
                    if (!pos) continue;  // User not in this chapter
                } else {
                    pos = parseInt(selectedPosition);
                }

                if (pos === 1 || pos === 2) anyQueen = true;

                if (ch.player_events) {
                    for (const evt of ch.player_events) {
                        if (evt.positions && evt.positions.includes(pos)) {
                            allEvents.push({
                                time: evt.time,
                                delta: evt.delta,
                                type: evt.type,
                                game_id: ch.game_id,
                                set_number: ch.set_number,
                                event_id: evt.id,
                                values: evt.values,
                                position: pos  // Store position for team-based delta display
                            });
                        }
                    }
                }
            }

            // Queen positions have higher thresholds (bigger swings are normal)
            const baseThreshold = anyQueen ? 0.20 : 0.15;

            // Sort by time
            allEvents.sort((a, b) => a.time - b.time);

            // Calculate impact score with clustering bonus
            // Events within 5 seconds of other impactful events get boosted
            const windowSize = 5; // seconds
            for (let i = 0; i < allEvents.length; i++) {
                let clusterScore = Math.abs(allEvents[i].delta);

                // Look for nearby events and sum their impact
                for (let j = 0; j < allEvents.length; j++) {
                    if (i !== j && Math.abs(allEvents[i].time - allEvents[j].time) < windowSize) {
                        clusterScore += Math.abs(allEvents[j].delta) * 0.3; // 30% bonus for nearby events
                    }
                }
                allEvents[i].score = clusterScore;
            }

            // Filter by threshold and take top events per set
            const targetPerSet = 4;
            const eventsBySet = {};

            for (const evt of allEvents) {
                if (evt.score >= baseThreshold) {
                    if (!eventsBySet[evt.set_number]) {
                        eventsBySet[evt.set_number] = [];
                    }
                    eventsBySet[evt.set_number].push(evt);
                }
            }

            // Take top N per set by score
            for (const setNum in eventsBySet) {
                eventsBySet[setNum].sort((a, b) => b.score - a.score);
                const topEvents = eventsBySet[setNum].slice(0, targetPerSet);
                playerHighlights.push(...topEvents);
            }

            // Check if there are any positive highlights for this player
            // If not, include their best positive move regardless of threshold
            const hasPositiveHighlight = playerHighlights.some(h => {
                const isGold = h.position && isGoldTeam(h.position);
                const displayDelta = isGold ? -h.delta : h.delta;
                return displayDelta > 0;
            });

            if (!hasPositiveHighlight && allEvents.length > 0) {
                // Find the best positive move (highest delta from player's perspective)
                let bestPositiveMove = null;
                let bestPositiveDelta = 0;

                for (const evt of allEvents) {
                    const isGold = evt.position && isGoldTeam(evt.position);
                    const displayDelta = isGold ? -evt.delta : evt.delta;
                    if (displayDelta > bestPositiveDelta) {
                        bestPositiveDelta = displayDelta;
                        bestPositiveMove = evt;
                    }
                }

                if (bestPositiveMove && !playerHighlights.some(h => h.id === bestPositiveMove.id)) {
                    playerHighlights.push(bestPositiveMove);
                }
            }

            // Sort final list by time for navigation
            playerHighlights.sort((a, b) => a.time - b.time);

            // Count highlights (good for player) vs lowlights (bad for player)
            let highlightCount = 0;
            let lowlightCount = 0;
            for (const h of playerHighlights) {
                const isGold = h.position && isGoldTeam(h.position);
                const displayDelta = isGold ? -h.delta : h.delta;
                if (displayDelta >= 0) {
                    highlightCount++;
                } else {
                    lowlightCount++;
                }
            }
            document.getElementById('highlightCount').innerHTML =
                `<span class="good-prob">${highlightCount}</span> / <span class="bad-prob">${lowlightCount}</span>`;

            // Update debug UI
            renderHighlightDebug();
        }

        // Render the highlight debug panel
        function renderHighlightDebug() {
            const debugEl = document.getElementById('highlightDebug');

            if (!selectedUserId && !selectedPosition) {
                debugEl.innerHTML = '';
                return;
            }

            if (playerHighlights.length === 0) {
                debugEl.innerHTML = '<p class="highlight-debug-empty">No highlights found for this player</p>';
                return;
            }

            // Get player name and icon for header
            let playerName = 'Selected Player';
            let playerIcon = '';
            if (selectedUserId && users[selectedUserId]) {
                playerName = users[selectedUserId].name;
                // Get the position icon for the current chapter
                if (currentChapterIndex >= 0) {
                    const pos = getUserPositionInChapter(selectedUserId, chapters[currentChapterIndex]);
                    if (pos) playerIcon = getPositionIconImg(String(pos), 20);
                }
            } else if (selectedPosition) {
                playerName = POSITION_NAMES[selectedPosition] || `Position ${selectedPosition}`;
                playerIcon = getPositionIconImg(selectedPosition, 20);
            }

            // Count highlights vs lowlights and build items HTML
            let highlightCount = 0;
            let lowlightCount = 0;
            const itemsHtml = playerHighlights.map((h, idx) => {
                // Check if player is on gold team for this specific event
                const isGold = h.position && isGoldTeam(h.position);
                // For gold players, flip the delta since it's from blue's perspective
                const displayDelta = isGold ? -h.delta : h.delta;
                const deltaClass = displayDelta >= 0 ? 'positive' : 'negative';
                if (displayDelta >= 0) highlightCount++; else lowlightCount++;
                const deltaStr = (displayDelta >= 0 ? '+' : '') + (displayDelta * 100).toFixed(0) + '%';
                const scoreStr = h.score ? `(${(h.score * 100).toFixed(0)})` : '';
                const valuesStr = h.values ? h.values.join(', ') : '';
                const eventIdStr = h.event_id ? `#${h.event_id}` : '';

                // Add position icon for this specific event
                const posIcon = h.position ? getPositionIconImg(String(h.position), 14) : '';

                return `
                    <div class="highlight-debug-item" data-highlight-index="${idx}">
                        <span class="highlight-debug-pos">${posIcon}</span>
                        <span class="highlight-debug-time">${formatTime(h.time)}</span>
                        <span class="highlight-debug-delta ${deltaClass}">${deltaStr}</span>
                        <span class="highlight-debug-type">${h.type || 'event'} ${scoreStr}</span>
                        <span class="highlight-debug-game">Game ${h.game_id} ${eventIdStr}</span>
                    </div>
                    ${valuesStr ? `<div class="highlight-debug-values">[${valuesStr}]</div>` : ''}
                `;
            }).join('');

            debugEl.innerHTML = `
                <h4>${playerIcon}${playerName} - <span class="good-prob">${highlightCount}</span> / <span class="bad-prob">${lowlightCount}</span></h4>
                ${itemsHtml}
            `;

            // Add click handlers
            debugEl.querySelectorAll('.highlight-debug-item').forEach(el => {
                el.addEventListener('click', () => {
                    const idx = parseInt(el.dataset.highlightIndex);
                    lastHighlightIndex = idx;
                    updateDebugActiveHighlight();
                    seekTo(playerHighlights[idx].time - HIGHLIGHT_SEEK_BUFFER);
                    if (player) player.playVideo();
                });
            });
        }

        // Update which debug item is marked as active
        function updateDebugActiveHighlight() {
            const debugEl = document.getElementById('highlightDebug');
            debugEl.querySelectorAll('.highlight-debug-item').forEach(el => {
                const idx = parseInt(el.dataset.highlightIndex);
                el.classList.toggle('active', idx === lastHighlightIndex);
            });
            // Scroll active item into view
            const activeEl = debugEl.querySelector('.highlight-debug-item.active');
            if (activeEl) {
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function nextHighlight() {
            if (playerHighlights.length === 0) return;

            const currentTime = getCurrentTime();
            let nextIndex;

            // If near last highlight, go to next
            if (lastHighlightIndex >= 0 && lastHighlightIndex < playerHighlights.length - 1) {
                const lastTime = playerHighlights[lastHighlightIndex].time;
                if (Math.abs(currentTime - (lastTime - HIGHLIGHT_SEEK_BUFFER)) < 3) {
                    nextIndex = lastHighlightIndex + 1;
                }
            }

            // Otherwise find based on current time
            if (nextIndex === undefined) {
                for (let i = 0; i < playerHighlights.length; i++) {
                    if (playerHighlights[i].time > currentTime + 0.5) {
                        nextIndex = i;
                        break;
                    }
                }
            }

            if (nextIndex !== undefined && nextIndex < playerHighlights.length) {
                lastHighlightIndex = nextIndex;
                updateDebugActiveHighlight();
                seekTo(playerHighlights[nextIndex].time - HIGHLIGHT_SEEK_BUFFER);
                if (player) player.playVideo();
            }
        }

        function prevHighlight() {
            if (playerHighlights.length === 0) return;

            const currentTime = getCurrentTime();

            // If near last highlight, replay or go to previous
            if (lastHighlightIndex >= 0) {
                const lastTime = playerHighlights[lastHighlightIndex].time;

                // If past the event, replay it
                if (currentTime > lastTime - 0.5) {
                    seekTo(lastTime - HIGHLIGHT_SEEK_BUFFER);
                    if (player) player.playVideo();
                    return;
                }

                // If near the start, go to previous
                if (Math.abs(currentTime - (lastTime - HIGHLIGHT_SEEK_BUFFER)) < 2 && lastHighlightIndex > 0) {
                    lastHighlightIndex--;
                    updateDebugActiveHighlight();
                    seekTo(playerHighlights[lastHighlightIndex].time - HIGHLIGHT_SEEK_BUFFER);
                    if (player) player.playVideo();
                    return;
                }
            }

            // Otherwise find based on current time
            for (let i = playerHighlights.length - 1; i >= 0; i--) {
                if (playerHighlights[i].time < currentTime - 1) {
                    lastHighlightIndex = i;
                    updateDebugActiveHighlight();
                    seekTo(playerHighlights[i].time - HIGHLIGHT_SEEK_BUFFER);
                    if (player) player.playVideo();
                    return;
                }
            }
        }

        // Load chapters from JSON
        function loadChaptersFromJSON(data) {
            chapters = data.chapters || [];
            users = data.users || {};
            videoId = data.video_id || null;

            // Build flat list of queen kills from all chapters
            queenKills = [];
            for (const ch of chapters) {
                if (ch.queen_kills) {
                    for (const qk of ch.queen_kills) {
                        queenKills.push({
                            time: qk.time,
                            victim: qk.victim,
                            game_id: ch.game_id
                        });
                    }
                }
            }
            // Sort by time (should already be sorted, but ensure it)
            queenKills.sort((a, b) => a.time - b.time);

            // Populate player dropdowns (desktop and mobile)
            const playerSelect = document.getElementById('playerSelect');
            const mobilePlayerSelect = document.getElementById('mobilePlayerSelect');
            playerSelect.innerHTML = '<option value="">Select player...</option>';
            mobilePlayerSelect.innerHTML = '<option value="">Player...</option>';
            const sortedUsers = Object.entries(users)
                .sort((a, b) => a[1].name.toLowerCase().localeCompare(b[1].name.toLowerCase()));
            for (const [userId, userInfo] of sortedUsers) {
                const option = document.createElement('option');
                option.value = userId;
                option.textContent = userInfo.name;
                playerSelect.appendChild(option);
                // Clone for mobile
                mobilePlayerSelect.appendChild(option.cloneNode(true));
            }

            // Check URL for player param and select that player
            const urlParams = new URLSearchParams(window.location.search);
            const playerParam = urlParams.get('player');
            if (playerParam && users[playerParam]) {
                playerSelect.value = playerParam;
                mobilePlayerSelect.value = playerParam;
                handlePlayerSelect(playerParam, false);  // false = don't update URL again
            }

            renderChapters();
            updateCurrentChapter();
            console.log(`Loaded ${chapters.length} chapters with ${queenKills.length} queen kills and ${Object.keys(users).length} users`);
            if (chapters.length > 0) {
                console.log(`First chapter at ${chapters[0].start_time}s, last at ${chapters[chapters.length-1].start_time}s`);
            }

            // Initialize YouTube player now that we have the video ID
            initializePlayer();
        }

        // Event listeners
        document.getElementById('prevChapter').addEventListener('click', prevChapter);
        document.getElementById('nextChapter').addEventListener('click', nextChapter);
        document.getElementById('prevSet').addEventListener('click', prevSet);
        document.getElementById('nextSet').addEventListener('click', nextSet);
        document.getElementById('prevEgg').addEventListener('click', prevQueenKill);
        document.getElementById('nextEgg').addEventListener('click', nextQueenKill);
        document.getElementById('prevHighlightBtn').addEventListener('click', prevHighlight);
        document.getElementById('nextHighlightBtn').addEventListener('click', nextHighlight);
        playPauseBtn.addEventListener('click', togglePlayPause);

        chapterFilter.addEventListener('input', (e) => {
            renderChapters(e.target.value);
        });

        // Helper: get user's position in a chapter
        function getUserPositionInChapter(userId, chapter) {
            if (!chapter.users) return null;
            for (const [pos, uid] of Object.entries(chapter.users)) {
                if (String(uid) === String(userId)) {
                    return parseInt(pos);
                }
            }
            return null;
        }

        // Player selector (by name) - shared handler for desktop and mobile
        function handlePlayerSelect(userId, updateUrl = true) {
            selectedUserId = userId;
            // Clear position selectors when using player selector
            document.getElementById('positionSelect').value = '';
            document.getElementById('mobilePositionSelect').value = '';

            if (selectedUserId && currentChapterIndex >= 0) {
                // Find this user's position in the current chapter
                const pos = getUserPositionInChapter(selectedUserId, chapters[currentChapterIndex]);
                selectedPosition = pos ? String(pos) : null;
            } else {
                selectedPosition = null;
            }

            // Update URL with player param
            if (updateUrl) {
                const url = new URL(window.location);
                if (userId) {
                    url.searchParams.set('player', userId);
                } else {
                    url.searchParams.delete('player');
                }
                window.history.replaceState({}, '', url);
            }

            updatePlayerHighlights();
            renderChapters(chapterFilter.value);
        }

        document.getElementById('playerSelect').addEventListener('change', (e) => {
            handlePlayerSelect(e.target.value);
            // Sync mobile selector
            document.getElementById('mobilePlayerSelect').value = e.target.value;
        });

        document.getElementById('mobilePlayerSelect').addEventListener('change', (e) => {
            handlePlayerSelect(e.target.value);
            // Sync desktop selector
            document.getElementById('playerSelect').value = e.target.value;
        });

        // Position selector
        document.getElementById('positionSelect').addEventListener('change', (e) => {
            selectedPosition = e.target.value;
            selectedUserId = null;  // Clear user selection when using position
            document.getElementById('playerSelect').value = '';
            document.getElementById('mobilePlayerSelect').value = '';
            updatePlayerHighlights();
            renderChapters(chapterFilter.value);  // Re-render to show player dots on plots
            // Sync mobile selector
            document.getElementById('mobilePositionSelect').value = selectedPosition;
        });

        // Mobile controls
        let mobileControlsVisible = true;

        document.getElementById('mobileToggle').addEventListener('click', () => {
            mobileControlsVisible = !mobileControlsVisible;
            document.getElementById('mobileControls').classList.toggle('visible', mobileControlsVisible);
            document.getElementById('mobileToggle').textContent = mobileControlsVisible ? '‚úï' : '‚ò∞';
        });

        document.getElementById('mPrevSet').addEventListener('click', prevSet);
        document.getElementById('mNextSet').addEventListener('click', nextSet);
        document.getElementById('mPrevGame').addEventListener('click', prevChapter);
        document.getElementById('mNextGame').addEventListener('click', nextChapter);
        document.getElementById('mPrevHighlight').addEventListener('click', prevHighlight);
        document.getElementById('mNextHighlight').addEventListener('click', nextHighlight);

        document.getElementById('mobilePositionSelect').addEventListener('change', (e) => {
            selectedPosition = e.target.value;
            selectedUserId = null;  // Clear user selection when using position
            // Sync desktop selectors and clear player selectors
            document.getElementById('positionSelect').value = selectedPosition;
            document.getElementById('playerSelect').value = '';
            document.getElementById('mobilePlayerSelect').value = '';
            updatePlayerHighlights();
            renderChapters(chapterFilter.value);
        });

        // File loading (hidden input, kept for flexibility)
        document.getElementById('chaptersInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        loadChaptersFromJSON(data);
                    } catch (err) {
                        alert('Error parsing chapters.json: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT') return;

            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlayPause();
                    break;
                case 'ArrowLeft':
                    seekTo(getCurrentTime() - 5);
                    break;
                case 'ArrowRight':
                    seekTo(getCurrentTime() + 5);
                    break;
                case 'j':
                    seekTo(getCurrentTime() - 10);
                    break;
                case 'l':
                    seekTo(getCurrentTime() + 10);
                    break;
                case 'p':
                    prevChapter();
                    break;
                case 'n':
                    nextChapter();
                    break;
                case 'g':
                    nextChapter();
                    break;
                case 'G':
                    prevChapter();
                    break;
                case 's':
                    nextSet();
                    break;
                case 'S':
                    prevSet();
                    break;
                case 'e':
                    nextQueenKill();
                    break;
                case 'E':
                    prevQueenKill();
                    break;
                case 'h':
                    nextHighlight();
                    break;
                case 'H':
                    prevHighlight();
                    break;
                case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9': case '0':
                    // Map keyboard to internal position IDs (viewer perspective)
                    const keyToPosition = {
                        '1': '10',  // Blue Checkers
                        '2': '8',   // Blue Skull
                        '3': '2',   // Blue Queen
                        '4': '9',   // Blue Abs
                        '5': '7',   // Blue Stripes
                        '6': '6',   // Gold Checkers
                        '7': '4',   // Gold Skull
                        '8': '1',   // Gold Queen
                        '9': '5',   // Gold Abs
                        '0': '3',   // Gold Stripes
                    };
                    const posSelect = document.getElementById('positionSelect');
                    posSelect.value = keyToPosition[e.key];
                    selectedPosition = keyToPosition[e.key];
                    updatePlayerHighlights();
                    renderChapters(chapterFilter.value);  // Re-render to show player dots on plots
                    // Sync mobile selector
                    document.getElementById('mobilePositionSelect').value = selectedPosition;
                    break;
            }
        });

        // Get chapters URL from query parameter or use default
        const urlParams = new URLSearchParams(window.location.search);
        const chaptersUrl = urlParams.get('chapters') || 'chapters/tournaments/842.json';

        // Auto-load chapters file
        fetch(chaptersUrl)
            .then(r => {
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                return r.json();
            })
            .then(loadChaptersFromJSON)
            .catch((err) => console.log(`Failed to load ${chaptersUrl}: ${err.message}`));
    </script>
</body>
</html>
