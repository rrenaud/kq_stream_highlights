<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KQ Video Player</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .video-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
        }

        #player {
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
            margin-top: 10px;
        }

        .controls button {
            background: #0f3460;
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .controls button:hover {
            background: #e94560;
        }

        .controls button:disabled {
            background: #333;
            cursor: not-allowed;
        }

        .time-display {
            font-family: monospace;
            font-size: 14px;
            color: #aaa;
        }

        .current-chapter {
            padding: 10px 15px;
            background: #16213e;
            border-radius: 8px;
            margin-top: 10px;
        }

        .current-chapter h3 {
            color: #e94560;
            margin-bottom: 5px;
        }

        .chapter-sidebar {
            width: 350px;
            background: #16213e;
            overflow-y: auto;
            border-left: 1px solid #0f3460;
        }

        .sidebar-header {
            padding: 20px;
            background: #0f3460;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sidebar-header h2 {
            margin-bottom: 10px;
        }

        .sidebar-header input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            background: #1a1a2e;
            color: #fff;
            font-size: 14px;
        }

        .chapter-list {
            padding: 10px;
        }

        .chapter-item {
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 4px;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .chapter-item:hover {
            background: #0f3460;
        }

        .chapter-item.active {
            background: #0f3460;
            border-left-color: #e94560;
        }

        .chapter-item.gold-win {
            border-right: 3px solid #ffd700;
        }

        .chapter-item.blue-win {
            border-right: 3px solid #4a90d9;
        }

        /* Set styling */
        .chapter-item.set-start {
            margin-top: 16px;
            padding: 14px;
            background: #0f3460;
            border-left: 3px solid #e94560;
        }

        .chapter-item.set-start:first-child {
            margin-top: 0;
        }

        .chapter-item.in-set {
            margin-left: 20px;
            padding: 8px 12px;
            font-size: 0.9em;
            opacity: 0.85;
        }

        .chapter-item.in-set .chapter-title {
            font-size: 0.95em;
        }

        .chapter-item.in-set .chapter-time,
        .chapter-item.in-set .chapter-meta {
            font-size: 11px;
        }

        .set-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #e94560;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .chapter-time {
            font-family: monospace;
            font-size: 12px;
            color: #888;
            margin-bottom: 4px;
        }

        .chapter-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .chapter-meta {
            font-size: 12px;
            color: #aaa;
        }

        .chapter-meta .winner {
            font-weight: 600;
        }

        .chapter-meta .gold { color: #ffd700; }
        .chapter-meta .blue { color: #4a90d9; }

        .load-section {
            padding: 20px;
            text-align: center;
        }

        .keyboard-hints {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .keyboard-hints kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-section">
            <div class="video-wrapper">
                <div id="player"></div>
            </div>

            <div class="controls">
                <button id="prevChapter" title="Previous chapter">⏮ Prev</button>
                <button id="nextChapter" title="Next chapter">Next ⏭</button>
                <button id="playPause">▶ Play</button>
                <span class="time-display" id="timeDisplay">0:00 / 0:00</span>
                <div style="flex: 1;"></div>
                <button id="loadChapters">Load Chapters</button>
            </div>

            <div class="current-chapter" id="currentChapterInfo">
                <h3>No chapter loaded</h3>
                <p>Load chapters.json to begin</p>
            </div>

            <div class="keyboard-hints">
                <kbd>←</kbd><kbd>→</kbd> Seek 5s &nbsp;
                <kbd>J</kbd><kbd>L</kbd> Seek 10s &nbsp;
                <kbd>Space</kbd> Play/Pause<br>
                <kbd>G</kbd> Game (Shift: prev) &nbsp;
                <kbd>S</kbd> Set (Shift: prev) &nbsp;
                <kbd>E</kbd> Egg/queen kill (Shift: prev)
            </div>
        </div>

        <div class="chapter-sidebar">
            <div class="sidebar-header">
                <h2>Chapters</h2>
                <input type="text" id="chapterFilter" placeholder="Filter by map, winner...">
            </div>
            <div class="chapter-list" id="chapterList">
                <div class="load-section">
                    <p>No chapters loaded</p>
                    <p style="font-size: 12px; color: #666; margin-top: 10px;">
                        Generate chapters with:<br>
                        <code>python generate_chapters.py video.mkv cabinet_url</code>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="chaptersInput" accept=".json" style="display: none;">

    <!-- YouTube IFrame API -->
    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        const chapterList = document.getElementById('chapterList');
        const currentChapterInfo = document.getElementById('currentChapterInfo');
        const timeDisplay = document.getElementById('timeDisplay');
        const chapterFilter = document.getElementById('chapterFilter');
        const playPauseBtn = document.getElementById('playPause');

        let player;
        let chapters = [];
        let queenKills = [];  // Flat list of all queen kill timestamps
        let currentChapterIndex = -1;
        let lastQueenKillIndex = -1;  // Track last navigated queen kill
        let timeUpdateInterval;

        // YouTube video ID
        const VIDEO_ID = 'UmxLa4CW9cY';

        // Initialize YouTube player
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                videoId: VIDEO_ID,
                playerVars: {
                    'autoplay': 0,
                    'controls': 1,
                    'rel': 0,
                    'modestbranding': 1,
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        function onPlayerReady(event) {
            console.log('YouTube player ready');
            // Start time update interval
            timeUpdateInterval = setInterval(updateCurrentChapter, 500);
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                playPauseBtn.textContent = '⏸ Pause';
            } else {
                playPauseBtn.textContent = '▶ Play';
            }
        }

        // Get current time from YouTube player
        function getCurrentTime() {
            return player && player.getCurrentTime ? player.getCurrentTime() : 0;
        }

        // Get video duration
        function getDuration() {
            return player && player.getDuration ? player.getDuration() : 0;
        }

        // Seek to time
        function seekTo(seconds) {
            if (player && player.seekTo) {
                player.seekTo(seconds, true);
            }
        }

        // Play/Pause
        function togglePlayPause() {
            if (!player) return;
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        }

        // Format time as M:SS or H:MM:SS
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) {
                return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Find chapter at current time
        function findChapterAtTime(time) {
            for (let i = chapters.length - 1; i >= 0; i--) {
                if (time >= chapters[i].start_time) {
                    return i;
                }
            }
            return -1;
        }

        // Update current chapter display
        function updateCurrentChapter() {
            const currentTime = getCurrentTime();
            const newIndex = findChapterAtTime(currentTime);

            if (newIndex !== currentChapterIndex) {
                currentChapterIndex = newIndex;

                // Update sidebar highlighting
                document.querySelectorAll('.chapter-item').forEach((el, i) => {
                    el.classList.toggle('active', i === currentChapterIndex);
                });

                // Scroll active chapter into view
                const activeEl = document.querySelector('.chapter-item.active');
                if (activeEl) {
                    activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            // Update info panel
            if (currentChapterIndex >= 0) {
                const ch = chapters[currentChapterIndex];
                currentChapterInfo.innerHTML = `
                    <h3>${ch.title}</h3>
                    <p>
                        <span class="${ch.winner}">${ch.winner}</span> wins by ${ch.win_condition}
                        &nbsp;|&nbsp; Duration: ${formatTime(ch.duration)}
                        &nbsp;|&nbsp; <a href="${ch.hivemind_url}" target="_blank" style="color: #e94560;">HiveMind</a>
                    </p>
                `;
            }

            // Update time display
            timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(getDuration())}`;
        }

        // Render chapter list
        function renderChapters(filter = '') {
            const filterLower = filter.toLowerCase();

            chapterList.innerHTML = chapters
                .map((ch, i) => {
                    // Filter
                    if (filter) {
                        const searchText = `${ch.map} ${ch.winner} ${ch.win_condition} ${ch.game_id}`.toLowerCase();
                        if (!searchText.includes(filterLower)) {
                            return '';
                        }
                    }

                    const winnerClass = ch.winner === 'gold' ? 'gold-win' : 'blue-win';
                    const activeClass = i === currentChapterIndex ? 'active' : '';
                    const setClass = ch.is_set_start ? 'set-start' : 'in-set';
                    const setLabel = ch.is_set_start ? `<div class="set-label">Set ${ch.set_number}</div>` : '';

                    return `
                        <div class="chapter-item ${winnerClass} ${activeClass} ${setClass}" data-index="${i}">
                            ${setLabel}
                            <div class="chapter-time">${formatTime(ch.start_time)} - ${formatTime(ch.end_time)}</div>
                            <div class="chapter-title">${ch.title}</div>
                            <div class="chapter-meta">
                                <span class="winner ${ch.winner}">${ch.winner}</span> ${ch.win_condition}
                                &nbsp;|&nbsp; ${formatTime(ch.duration)}
                            </div>
                        </div>
                    `;
                })
                .join('');

            // Add click handlers
            document.querySelectorAll('.chapter-item').forEach(el => {
                el.addEventListener('click', () => {
                    const index = parseInt(el.dataset.index);
                    jumpToChapter(index);
                });
            });
        }

        // Jump to chapter
        function jumpToChapter(index) {
            if (index >= 0 && index < chapters.length) {
                const targetTime = chapters[index].start_time;
                console.log(`Jumping to chapter ${index}: ${chapters[index].title} at ${targetTime}s`);
                seekTo(targetTime);
                currentChapterIndex = index;
                updateCurrentChapter();
                if (player) player.playVideo();
            }
        }

        // Navigation
        function prevChapter() {
            const idx = findChapterAtTime(getCurrentTime());
            if (idx > 0) {
                jumpToChapter(idx - 1);
            } else if (idx === 0) {
                jumpToChapter(0);
            }
        }

        function nextChapter() {
            const idx = findChapterAtTime(getCurrentTime());
            if (idx < chapters.length - 1) {
                jumpToChapter(idx + 1);
            } else if (idx === -1 && chapters.length > 0) {
                jumpToChapter(0);
            }
        }

        // Set navigation
        function nextSet() {
            const idx = findChapterAtTime(getCurrentTime());
            for (let i = idx + 1; i < chapters.length; i++) {
                if (chapters[i].is_set_start) {
                    jumpToChapter(i);
                    return;
                }
            }
        }

        function prevSet() {
            const idx = findChapterAtTime(getCurrentTime());
            // If we're past the start of current set's first game, go to current set start
            const currentSetStart = chapters.findIndex((ch, i) =>
                i <= idx && ch.is_set_start &&
                (i === idx || !chapters.slice(i + 1, idx + 1).some(c => c.is_set_start))
            );

            // Find previous set start
            for (let i = idx - 1; i >= 0; i--) {
                if (chapters[i].is_set_start) {
                    // If we're at the start of current set, go to previous set
                    if (i === currentSetStart && getCurrentTime() - chapters[i].start_time < 2) {
                        continue;
                    }
                    jumpToChapter(i);
                    return;
                }
            }
            // If no previous set, go to first chapter
            if (chapters.length > 0) {
                jumpToChapter(0);
            }
        }

        // Queen kill (egg) navigation
        function findQueenKillIndexAtTime(time) {
            // Find the queen kill at or just before the given time
            for (let i = queenKills.length - 1; i >= 0; i--) {
                if (queenKills[i].time <= time + 2) {
                    return i;
                }
            }
            return -1;
        }

        function nextQueenKill() {
            if (queenKills.length === 0) return;

            const currentTime = getCurrentTime();
            let nextIndex;

            // If we're near the last jumped-to kill, go to the next one
            if (lastQueenKillIndex >= 0 && lastQueenKillIndex < queenKills.length - 1) {
                const lastKillTime = queenKills[lastQueenKillIndex].time;
                if (Math.abs(currentTime - (lastKillTime - 1)) < 3) {
                    nextIndex = lastQueenKillIndex + 1;
                }
            }

            // Otherwise find based on current time
            if (nextIndex === undefined) {
                nextIndex = findQueenKillIndexAtTime(currentTime) + 1;
            }

            if (nextIndex < queenKills.length) {
                lastQueenKillIndex = nextIndex;
                seekTo(queenKills[nextIndex].time - 1);
                if (player) player.playVideo();
            }
        }

        function prevQueenKill() {
            if (queenKills.length === 0) return;

            const currentTime = getCurrentTime();
            let prevIndex;

            // If we're near the last jumped-to kill, go to the previous one
            if (lastQueenKillIndex > 0) {
                const lastKillTime = queenKills[lastQueenKillIndex].time;
                if (Math.abs(currentTime - (lastKillTime - 1)) < 3) {
                    prevIndex = lastQueenKillIndex - 1;
                }
            }

            // Otherwise find based on current time
            if (prevIndex === undefined) {
                prevIndex = findQueenKillIndexAtTime(currentTime - 2);
            }

            if (prevIndex >= 0) {
                lastQueenKillIndex = prevIndex;
                seekTo(queenKills[prevIndex].time - 1);
                if (player) player.playVideo();
            }
        }

        // Load chapters from JSON
        function loadChaptersFromJSON(data) {
            chapters = data.chapters || [];

            // Build flat list of queen kills from all chapters
            queenKills = [];
            for (const ch of chapters) {
                if (ch.queen_kills) {
                    for (const qk of ch.queen_kills) {
                        queenKills.push({
                            time: qk.time,
                            victim: qk.victim,
                            game_id: ch.game_id
                        });
                    }
                }
            }
            // Sort by time (should already be sorted, but ensure it)
            queenKills.sort((a, b) => a.time - b.time);

            renderChapters();
            updateCurrentChapter();
            console.log(`Loaded ${chapters.length} chapters with ${queenKills.length} queen kills`);
            if (chapters.length > 0) {
                console.log(`First chapter at ${chapters[0].start_time}s, last at ${chapters[chapters.length-1].start_time}s`);
            }
        }

        // Event listeners
        document.getElementById('prevChapter').addEventListener('click', prevChapter);
        document.getElementById('nextChapter').addEventListener('click', nextChapter);
        playPauseBtn.addEventListener('click', togglePlayPause);

        chapterFilter.addEventListener('input', (e) => {
            renderChapters(e.target.value);
        });

        // File loading
        document.getElementById('loadChapters').addEventListener('click', () => {
            document.getElementById('chaptersInput').click();
        });

        document.getElementById('chaptersInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        loadChaptersFromJSON(data);
                    } catch (err) {
                        alert('Error parsing chapters.json: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT') return;

            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlayPause();
                    break;
                case 'ArrowLeft':
                    seekTo(getCurrentTime() - 5);
                    break;
                case 'ArrowRight':
                    seekTo(getCurrentTime() + 5);
                    break;
                case 'j':
                    seekTo(getCurrentTime() - 10);
                    break;
                case 'l':
                    seekTo(getCurrentTime() + 10);
                    break;
                case 'p':
                    prevChapter();
                    break;
                case 'n':
                    nextChapter();
                    break;
                case 'g':
                    nextChapter();
                    break;
                case 'G':
                    prevChapter();
                    break;
                case 's':
                    nextSet();
                    break;
                case 'S':
                    prevSet();
                    break;
                case 'e':
                    nextQueenKill();
                    break;
                case 'E':
                    prevQueenKill();
                    break;
            }
        });

        // Try to auto-load chapters.json from same directory
        fetch('chapters.json')
            .then(r => r.json())
            .then(loadChaptersFromJSON)
            .catch(() => console.log('No chapters.json found, load manually'));
    </script>
</body>
</html>
